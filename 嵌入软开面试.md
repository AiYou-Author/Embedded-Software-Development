# 第一章进程线程



## 1.1 进程线程的基本概念



### 1.1.1 什么是进程，线程，彼此有什么区别



**PCB，程序段，数据段**三部分构成了进程实体

进程就是进程实体的运行过程，是系统进行**资源分配**和**调度**的一个独立单位



线程为**程序执行流的最小单位**

线程为CPU分配时间资源的基本单元



**区别**：

一个进程可以拥有多个线程。同一进程的不同线程间共享进程的资源。

通信：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间直接使用进程数据段进行通信

调度和切换：同一进程间切换系统开销很小



### 1.1.2 多进程、多线程的优缺点



多进程

优点：多进程使用独立的地址以及资源，一个进程结束不会影响其他进程

缺点：多进程进行任务切换，会大量浪费CPU资源



多线程

优点：任务切换效率高；所有线程共享内存和变量；多线程间通信较为容易

缺点：一个线程崩溃影响整个进程；线程之间的同步和加锁控制比较麻烦；

|          | 多进程                                         | 多线程                                                       |
| :------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 资源     | 多进程使用独立的地址以及资源，进程之间互不影响 | 多线程共用地址以及资源，同一进程中的一个线程死了会影响其他线程 |
| 性能     | 多进程更强，享有独立资源                       | 多线程共用资源                                               |
| 花销     | 进程切换效率低，耗费大量资源                   | 线程切效率高                                                 |
| 通信     | 进程间通信需跨越进程边界                       | 线程间通信使用共享内存和变量                                 |
| 控制逻辑 | 多进程更为复杂                                 | 多线程控制逻辑更为容易，但是需要线程同步和加锁控制           |
| 数量     | 进程数量由CPU决定                              | 线程数量由进程的空间资源和线程本身栈大小决定                 |



### 1.1.3 什么时候用进程，什么时候用线程

需要频繁快速切换的时候选择线程

需要安全稳定时选择进程







### 1.1.4多进程、多线程同步的方法

进程间通信：

- 管道、无名管道
- 消息队列
- 信号量
- 共享内存
- 信号
- socket

线程间通信：

- 信号量
- 读写锁
- 条件变量
- 互斥锁
- 自旋锁

#### 互斥锁与信号量的区别

互斥锁用于线程互斥，信号量用于线程同步以及进程同步









### 1.1.5 进程的空间模型

![img](https://s2.loli.net/2022/06/23/36YvmCrwjh5SQbi.png)

32位系统，运行程序创建进程时，为其分配4G的虚拟地址空间，3G为用户空间，1G为内核空间

栈：由编译器自动分配和释放，存放函数的参数值，局部变量等

堆：一般由程序员分配和释放，若不释放会造成内存泄漏，程序结束可能又操作系统收回。

全局区：全局变量和静态变量放在一起，分为未初始化（.bss）和初始化（.data）的区域

文字常量区：常量字符串，程序结束后由系统释放（.rodata）

程序代码区：存放函数的二进制代码（.txt）



### 1.1.6 一个进程可以创建多少个线程，和什么有关



一个进程的可用虚拟空间为2G，默认情况下，线程的栈的大小为1MB，理论上可以创建2048个线程。

一个进程可以创建的线程个数由虚拟空间大小以及线程栈的大小决定。







### 1.1.7 进程线程的状态转换图，什么时候阻塞，什么时候就绪？

创建态：进程正在被创建，初识PCB，分配资源

就绪态：进程已具备除CPU外的所有资源

运行态：占用CPU，在处理机上运行

阻塞态：由于等待某些资源而导致进程暂停运行

结束态：撤销进程，撤销PCB，撤销资源

挂起态：由于某些资源得不到，将进程挂入外存

![image-20220530154124719](https://s2.loli.net/2022/06/23/DVRkhzH2lP9ox5I.png)







### 1.1.8 父进程，子进程的关系和区别

子进程继承父进程：

   ○用户号UIDs和用户组号GIDs

   ○环境Environment

   ○堆栈

   ○共享内存

   ○打开文件的描述符

   ○执行时关闭（Close-on-exec）标志

   ○信号（Signal）控制设定

   ○进程组号

   ○当前工作目录

   ○根目录

   ○文件方式创建屏蔽字

   ○资源限制

   ○控制终端

子进程独有的：

   ○进程号PID

   ○不同的父进程号

   ○自己的文件描述符和目录流的拷贝

   ○子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）

   ○不继承异步输入和输出 



父进程：

子进程：由父进程使用fork()系统调用创建。

**联系：**

创建子进程作为父进程的副本；子进程继承父进程大部分的属性。

子进程与父进程拥有相同内容的代码段、数据段和用户堆栈，目录。

**区别**：

子进程拥有自己的进程号PID，拥有独立的地址空间，自己的文件描述符和目录流的拷贝





### 1.1.9 什么是进程上下文，中断上下文

**进程上下文**：

​	一个进程在执行的时候，CPU中的所有寄存器中的值，进程的状态以及堆栈中的内容，当需要切换到另外一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次运行此进程时，能够恢复切换前的状态。

​	切换到内核态后执行的程序，即运行在内核空间的部分。



**中断上下文：**

​	由硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文可以理解为硬件传递过来的这些参数和内核需要保存的一些环境。

​	当用户进程想要访问系统资源，必须通过系统调用或者中断切换到内核态，由内核执行。









## 1.2 并发、同步、异步、互斥、阻塞、非阻塞的理解





### 1.2.1 并发、同步、异步、互斥、阻塞、非阻塞的概念

**并发**：两个或多个事件在同一时间间隔发生，就是微观上交替发生，宏观上同时发生。

**同步**：两个或多个进程的运行必须按照严格的先后顺序进行

**互斥**：对于某些临界资源的访问，需要互斥的进行，同一时段只允许一个进程访问该资源。

**异步**：异步彼此独立，不需要等待某个事件的发生才能工作

**注意：**

1）线程是实现异步的一个方式。可以在主线程创建一个新线程来做某件事，此时主线程不需等待子线程做完而是可以做其他事情。

2）异步和多线程并不是一个同等关系。异步是最终目的,多线程只是我们实现异步的一种手段。

**阻塞**：指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

**非阻塞**：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。



一般来说可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。

**同步阻塞**：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果就一直等待，等待期间不做任何操作。

**同步非阻塞**：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果，就立即返回，接收方继续做他事情，此时并未响应发送方，发送发就一直等待，直到接收方读取结果响应发送方，接收方才可以进入下一次请求。

**异步阻塞**：发送方发出请求后，不等待响应，继续其他工作（异步），接收方开始读取文件，如果不能马上得到读取结果就一直等待，等待期间不做任何操作。

**异步非阻塞**：发送方发出请求后，不等待响应，继续其他工作（异步），接收方读取文件如果不能马上得到结果，也不等待，而是马上返回取做其他事情。当IO操作（读取文件）完成以后，将完成状态和结果通知接收方，接收方在响应发送方。（效率最高）

**总结：** 

1）同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。

2）阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。

3）阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。



### 1.2.2 什么是线程同步和互斥

线程同步：线程之间的一种制约关系，一个线程依赖另一个线程的消息，每个线程都按照约定的先后次序运行

线程互斥：针对共享的临界资源，同一时段只允许一个线程访问资源，直到占用资源者释放资源后，其他线程才可以访问。





### 1.2.3 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？

**同步是一个过程，阻塞是一种状态。**

**线程同步不一定发生阻塞**，线程同步时，只有两个资源出现相互等待和相互唤醒时才会出现阻塞。











## 1.3 孤儿进程、僵尸进程、守护进程的概念







### 1.3.1 基本概念

**孤儿进程**：当父进程退出时，子进程仍然在运行，则子进程就是孤儿进程。

**僵尸进程**：子进程退出后，父进程没有调用wait()函数接收结束子进程，子进程停留在系统中，这就是僵尸进程。

**守护进程**：守护进程不受终端影响，退出终端也可以运行。



### 1.3.2 如何创建守护进程

1）**创建子进程，退出父进程**。利用`fork()`函数。

2）**创建新会话，摆脱终端影响**。利用`setsid()`函数创建新会话，并担任该会话组的组长，摆脱原会话的控制==>摆脱原进程的控制==>摆脱原控制台的控制。

3）**改变守护进程的工作目录为根目录**。利用`chrdir()`函数改变目录。

4）**重设文件权限掩码**。子进程继承了父进程的权限掩码，通过`umask()`函数屏蔽掉文件权限中的对应位，需要将子进程置零，拥有较大权限，提高守护进程灵活度。

5）**关闭不需要的文件描述符**。从父进程继承的文件描述符，不需要的可以关闭。

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>

int main()
{
        pid_t pid;
        int fd,len,i,num;
        char *buf="the dameon is running\n";
        len =strlen(buf)+1;


        pid=fork();
        if(pid>0)
        {
                exit(0);
        }

        //创建新会话，摆脱终端影响
        setsid();

        //改变当前工作目录
        chdir("/");

        //重设文件权限掩码
        umask(0);
    
		//关闭不需要的文件描述符
        for(int i=0;i<3;i++)
        {
                close(i);
        }

        while(1)
        {
                fd=open("/var/log/dameon.log",O_CREAT|O_WRONLY|O_APPEND,0666);
                write(fd,buf,len);
                close(fd);
                sleep(5);
        }
        return 0;
}
```









### 1.3.2 正确处理孤儿进程、僵尸进程的方法

**孤儿进程的处理：**

​	孤儿进程会有linux系统中的1号进程init进程来处理，他利用wait()函数来处理已经退出的子程序

**僵尸进程的处理：**

​	如果父进程一直不调用wait/waitpid函数接收子进程，那么子进程就一直保存在系统里，占用系统资源，因此如果僵尸进程数量太多，那么就会导致系统空间爆满，无法创建新的进程，严重系统工作

​	系统规定，子进程退出后，父进程会自动收到SIGCHLD信号。因此我们需要在父进程里重置signal函数。每当子进程退出，父进程都会收到SIGCHLD信号，故通过signal函数，重置信号响应函数。

```c
void* handler(int sig)
{
    int status;
    if(waitpid(-1, &status, WNOHANG) >= 0)
    {
        printf("child is die\n");
    }
}
int main()
{
    signal(SIGCHLD, handler);
    int pid = fork();
    if(pid > 0)  //父进程循环等待
    {
        while(1)
        {
            sleep(2);
        }
    
    }else if(0 == pid){   //子进程说自己die后就结束生命周期，之后父进程就收到SIGCHLD
                          //信号调用handler函数接收结束子进程，打印child is die。
        printf("i am child, i die\n");
    }
}
```





```c
pid_t wait(int *status);
pid_t waitpid(pid_t pid,int *status,int options);
```

`wait()`:

​	成功返回`pid`，失败返回-1；

`status:`

WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）

WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）



`waitpid()`:

​	成功返回`pid`，失败返回-1；

`pid：`

​	pid=-1,等待任意一个子进程，和wait等效

​	pid>0:只等待进程id等于pid的进程

​	pid=0:等待同一进程组的任意一个进程，如果子进程加入其他进程组不加理会

​	pid<-1时，等待一个指定进程组中的任意一个进程，这个进程组的id就是pid的绝对值

`status:`

​	WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）

​	WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）

`options:`

​	WNOHANG:若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回孩子进程的进程id



waitpid有wait没有的三个功能：

（1）waitpid能等待一个特定的子进程，而wait只能等待任意的子进程，

（2）系统一旦调用wait函数就会阻塞父进程来等待，直到等到子进程的退出才停止阻塞，而waitpid提供了一种非阻塞方式的等待，也就是第三个参数，当第三个参数设置为WNOHANG，当子进程没有结束，直接返回0，不等待

（3）waitpid支持作业控制，提供用于检查wait和waitpid返回状态的宏这两个函数返回的子进程的状态都保存在status指针中

WIFEXITED(status): 若为正常终止, 则为真. 此时可执行 WEXITSTATUS(status): 取子进程传送给exit或_exit参数的低8位.

WIFSIGNALED(status): 若为异常终止, 则为真.此时可执行 WTERMSIG(status): 取使子进程终止的信号编号.

WIFSTOPPED(status): 若为当前暂停子进程, 则为真. 此时可执行 WSTOPSIG(status): 取使子进程暂停的信号编号









# 第二章 C/C++







## 2.1 c和c++区别、概念相关面试题



### malloc和free

```c
(int*)malloc(4);
// 申请了一个四个字节的空间并且规定该空间为一个int型变量空间，而不是别的。

int *p =(int*)malloc(4);
// 由于malloc返回一个 空间地址，所以需要一个相应类型的指针来接收改地址

int *p;
p=(int*)malloc(4);
//也可以分写
```

```c
//堆区申请内存
int *p=malloc(sizeof(int)*5);  //申请了5个int类型的空间

//栈区申请内存
int a[5];
int *p=&a[0];

free(p);
```











### **2.1.1 new和malloc的区别**

1. new、delete是C++中独有的操作符，而malloc和free是C/C++中的标准库函数

2. 使用new创建对象在分配内存时会自动调用构造函数，同时完成对象的初始化。delete可以自动调用析构函数。

   malloc和free是库函数不是运算符，不能自动调用构造函数和析构函数。malloc只是单纯地为变量分配内存，free只是释放变量的内存。

3. new返回的是指定类型的指针，并可以自动计算所申请的内存大小。

   malloc返回的是void*类型，需要强行将其转换为实际类型的指针，并指定要申请内存的大小。

4. C++允许重载new/delete，而malloc和free是函数不可以重载

5. new分配内存失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL

6. 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。

   new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。







### **2.1.2 malloc的底层实现**

​	Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。我们用malloc进行内存分配就是从break往上进行的。

![img](https://s2.loli.net/2022/06/27/OBo16q5YmIlzETX.png)

malloc函数的实质是将一个可用的内存块链接为一个长长的空闲分区链表。调用malloc()函数时，它沿着链接表寻找一个大到足以满足用户需求的内存块。然后将内存块划分出用户申请的大小，将剩余部分返回到链接表。

free函数，将用户释放的内存空间连接到空闲链表。

​	 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。







### **2.1.3在1G内存的计算机中能否malloc(1.2G)？为什么？**

可以。

malloc函数向操作系统申请一块逻辑地址，与物理地址无直接联系。操作系统利用虚拟内存原理，完成逻辑地址与物理地址的转换。操作系统负责将信息从外存与内存之间调入调出，从而容纳超出内存大小的信息。







### **2.1.4指针与引用的相同和区别；如何相互转换？⭐⭐⭐⭐⭐**

**相同：都是地址的概念**

指针指向一块内存，它的内容是所指变量的地址。引用是某块内存的别名。

从内存来看，两者都占据内存。在32位系统中，指针一般占据4字节内存。引用为指针常量，无法使用sizeof查看其大小

**区别：**

1. 指针是一个实体，引用仅仅是别名；
2. 指针和引用的自增运算意义不同。指针是内存地址的自增，引用是变量值的自增；
3. 指针需要使用解除引用运算符。引用不需要
4. 引用只能在定义时进行初始化。指针可变。
5. 引用不能为空，指针可以为空
6. 引用没有const (int & const a),指针有const(int * const a：此指针不能改变其所指的变量)
7. sizeof 引用 得到是变量的大小；sizeof 指针 得到的是指针本身的大小

**引用和指针之间怎么转换**

1. 指针转引用：指针使用接触引用运算符就可以转换为对象

   ```c++
   void fun(int &val){}
   fun(*pA);
   ```

2. 引用转指针：引用类型的对象使用&取地址符，就可以获得指针

   ```c++
   int a=0;
   int *pA = &a;
   ```

   





### 2.1.5 C语言检索内存情况 内存分配的方式

检索内存：对某段内存进行遍历搜索

内存分配：

1. 静态存储区域分配。内存在程序编译时就已经分配好。如全局变量，常量，静态变量。
2. 栈。函数内局部变量的存储单元可以在栈上创建，函数执行结束时这些存储单元自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
3. 堆。动态内存分配。程序员需要自己申请动态内存并且释放内存。动态内存的生存期由程序员决定，若分配了空间未收回，则会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。











### 2.1.6  extern”C” 的作用⭐⭐⭐

**extern "C"**是C++特有的指令（C无法使用该指令），目的在于支持C++与C混合编程。

**extern “C”**的作用是告诉**C++编译器**用C规则编译指定的代码（除函数重载外，**extern “C”**不影响C++其他特性）。

**因为C和C++的编译规则不一样，主要区别体现在编译期间生成函数符号的规则不一致**

```c++
//func.h c文件
void func(int set);


//main.cpp c++文件
//法一:
extern "C"{
    #include "func.h"
}

//法二:
#include "func.h"
extern "C" void func(int set);
```





### 2.1.7头文件声明时加extern定义时不要加 因为extern可以多次声明，但只有一个定义⭐⭐⭐⭐

对于外部链接的变量，函数。extern修饰符用在变量和函数的声明前，说明此变量函数的定义在别处，且定义只有一个，此处引用声明。

**extern在链接阶段起作用。**







### 2.1.8函数参数压栈顺序，即关于`__stdcall`和`__cdecl`调用方式的理解⭐⭐⭐

`__stdcall`和`__cdecl`都是函数调用约定关键字，我们先来看看`__stdcall`和`__cdecl`调用方式的概念：

1）`__stdcall`是C++的标准调用方式，参数由右向左压入栈，函数在返回时会自动清除堆栈中的参数

2）`__cdecl`是C语言默认的函数调用方式，参数由右向左压入栈，函数在返回时不会自动清除堆栈中的参数，清除工作由调用者完成。

```c++
int __stdcall Func_stdcall(int nParam1, int nParam2)  
{  
    return 1;  
}  
int __cdecl Func_cdecl(int nParam1, int nParam2)  
{  
    return 1;  
}  
```









### 2.1.9重写memcpy()函数需要注意哪些问题⭐⭐

从存储区 str2 复制 n 个字节到存储区 str1。

```
 void *memcpy(void *str1, const void *str2, size_t n) 
```

- **str1** -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
- **str2** -- 指向要复制的数据源，类型强制转换为 void* 指针。
- **n** -- 要被复制的字节数。



情况一：两个数组不会重叠，从前至后赋值。

情况二：源地址数组在目标地址前，且两数组重叠，从后至前赋值。

情况三：源地址数组在目标地址后，且两数组重叠，从前至后赋值。

```c
 void *memcpy(void *str1, const void *str2, size_t n) 
 {
     char* pstr1;
     char* pstr2;
     if(str1==NULL||str2==NULL)
     {
         return NULL;
     }
     
     if(str2<str1 && ((char*)str2+n> (char*)str1))
     {
         pstr1=(char*)str1+n-1;
         pstr2=(char*)str2+n-1;
         while(n--)
         {
             *pstr1--=*pstr2--;
         }
     }else
     {
         pstr1=(char*)str1;
         pstr2=(char*)str2;
         while(n--)
         {
             *pstr1++=*pstr2++;
         }
     }
     return str1;
 }
```





### 2.1.10数组到底存放在哪里⭐⭐⭐

1. 定义在全局下的全局变量，就是在数据段里
2. 定义在函数下的局部变量，数组存放在函数调用栈里
3. 程序员使用new申请的动态内存，就是存放在自由存储区里
4. 固定数组在类中分配是在堆中







### 2.1.11  struct和class的区别 ⭐⭐⭐⭐⭐

区别：struct的默认访问控制为public；class的默认访问控制为private









### **2.1.12 char和int之间的转换；⭐⭐⭐**







### **2.1.13  static的用法（定义和用途）⭐⭐⭐⭐⭐**

### **2.1.14  cosnt的用法（定义和用途）⭐⭐⭐⭐⭐**

### **2.1.15const常量和#define的区别（编译阶段、安全性、内存占用等） ⭐⭐⭐⭐**
