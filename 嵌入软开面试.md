

# 第一章进程线程



## 1.1 进程线程的基本概念



### 1.1.1 什么是进程，线程，彼此有什么区别



**PCB，程序段，数据段**三部分构成了进程实体

进程就是进程实体的运行过程，是系统进行**资源分配**和**调度**的一个独立单位



线程为**程序执行流的最小单位**

线程为CPU分配时间资源的基本单元



**区别**：

一个进程可以拥有多个线程。同一进程的不同线程间共享进程的资源。

通信：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间直接使用进程数据段进行通信

调度和切换：同一进程间切换系统开销很小



### 1.1.2 多进程、多线程的优缺点



多进程

优点：多进程使用独立的地址以及资源，一个进程结束不会影响其他进程

缺点：多进程进行任务切换，会大量浪费CPU资源



多线程

优点：任务切换效率高；所有线程共享内存和变量；多线程间通信较为容易

缺点：一个线程崩溃影响整个进程；线程之间的同步和加锁控制比较麻烦；

|          | 多进程                                         | 多线程                                                       |
| :------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 资源     | 多进程使用独立的地址以及资源，进程之间互不影响 | 多线程共用地址以及资源，同一进程中的一个线程死了会影响其他线程 |
| 性能     | 多进程更强，享有独立资源                       | 多线程共用资源                                               |
| 花销     | 进程切换效率低，耗费大量资源                   | 线程切效率高                                                 |
| 通信     | 进程间通信需跨越进程边界                       | 线程间通信使用共享内存和变量                                 |
| 控制逻辑 | 多进程更为复杂                                 | 多线程控制逻辑更为容易，但是需要线程同步和加锁控制           |
| 数量     | 进程数量由CPU决定                              | 线程数量由进程的空间资源和线程本身栈大小决定                 |



### 1.1.3 什么时候用进程，什么时候用线程

需要频繁快速切换的时候选择线程

需要安全稳定时选择进程







### 1.1.4多进程、多线程同步的方法

进程间通信：

- 管道、无名管道
- 消息队列
- 信号量
- 共享内存
- 信号
- socket

线程间通信：

- 信号量
- 读写锁
- 条件变量
- 互斥锁
- 自旋锁

#### 互斥锁与信号量的区别

互斥锁用于线程互斥，信号量用于线程同步以及进程同步



#### **读写锁**

只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当处于读模式的读写锁接收到一个试图对其进行写模式加锁操作时，便会阻塞后面对其进行读模式加锁操作的线程。 即当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。这样当读模式的锁解锁后，要获得写状态锁的线程能够访问此锁保护的资源。所以读写锁非常适合资源的读操作远多于写操作的情况

1）多个读者可以同时进行读

2）写者必须互斥（只允许一个写者写，也不能读者写者同时进行）

3）写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）





#### **互斥锁**

在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前线程解锁。 如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源。



#### **自旋锁**

自旋锁是一种特殊的互斥锁，当资源被枷锁后，其他线程想要再次加锁，此时该线程不会被阻塞睡眠而是陷入循环等待状态（CPU不能做其它事情），循环检查资源持有者是否已经释放了资源，这样做的好处是减少了线程从睡眠到唤醒的资源消耗，但会一直占用CPU的资源。适用于资源的锁被持有的时间短，而又不希望在线程的唤醒上花费太多资源的情况。



从 实现原理上来讲，互斥锁属于sleep-waiting(睡眠等待)类型的锁。例如在一个双核的机器上有两个线程(线程A和线程B)，它们分别运行在Core0和 Core1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞 (blocking)，Core0 会在此时进行上下文切换(Context Switch)将线程A置于等待队列中，此时Core0就可以运行其他的任务(例如另一个线程C)而不必进行忙等待。而自旋锁则不然，它属于busy-waiting(忙等待)类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，那么线程A就会一直在 Core0上进行忙等待并不停的进行锁请求，直到得到这个锁为止。


### 顺序锁

**加锁过程**

顺序锁的实现主要依赖于序列计数器，这个序列计数器的技术是只增不减的。写任务访问添加顺序锁的数据的时候，首先会尝试获取顺序锁，如果成功获得顺序锁，则给序列计数器的计数加1 ；如果获取锁失败，则会挂起等待。获得锁的写任务执行完成写操作后，释放顺序锁之前会给序列计数器再加1。读操作不会有增加计数值的行为

**加锁依据**

从上面的描述可以看出，当有写任务在持有顺序锁的时候，序列计数器的计数是奇数，没有写任务执行的时候，计数是偶数。写任务判断是否能获取顺序锁的依据，就是该锁的计数是否是偶数。

对于读任务，在访问先回先判断计数是否是奇数，如果是奇数表示有写任务在执行，此时不会去执行读操作；如果计数是偶数，则去执行读操作，读完数据后会再次查询计数，检查是否和读数据之前的数据一样。如果读数据前后的计数一样，说明读数据期间没有发生写操作，读取到的数据是有效的；反之则说明读数据期间发生了写操作，读取到的数据是无效的。







### 1.1.5 进程的空间模型

![img](https://s2.loli.net/2022/06/23/36YvmCrwjh5SQbi.png)

32位系统，运行程序创建进程时，为其分配4G的虚拟地址空间，3G为用户空间，1G为内核空间

栈：由编译器自动分配和释放，存放函数的参数值，局部变量等

堆：一般由程序员分配和释放，若不释放会造成内存泄漏，程序结束可能又操作系统收回。

全局区：全局变量和静态变量放在一起，分为未初始化（.bss）和初始化（.data）的区域

文字常量区：常量字符串，程序结束后由系统释放（.rodata）

程序代码区：存放函数的二进制代码（.txt）



### 1.1.6 一个进程可以创建多少个线程，和什么有关



一个进程的可用虚拟空间为2G，默认情况下，线程的栈的大小为1MB，理论上可以创建2048个线程。

一个进程可以创建的线程个数由虚拟空间大小以及线程栈的大小决定。







### 1.1.7 进程线程的状态转换图，什么时候阻塞，什么时候就绪？

创建态：进程正在被创建，初识PCB，分配资源

就绪态：进程已具备除CPU外的所有资源

运行态：占用CPU，在处理机上运行

阻塞态：由于等待某些资源而导致进程暂停运行

结束态：撤销进程，撤销PCB，撤销资源

挂起态：由于某些资源得不到，将进程挂入外存

![image-20220530154124719](https://s2.loli.net/2022/06/23/DVRkhzH2lP9ox5I.png)







### 1.1.8 父进程，子进程的关系和区别

子进程继承父进程：

   ○用户号UIDs和用户组号GIDs

   ○环境Environment

   ○堆栈

   ○共享内存

   ○打开文件的描述符

   ○执行时关闭（Close-on-exec）标志

   ○信号（Signal）控制设定

   ○进程组号

   ○当前工作目录

   ○根目录

   ○文件方式创建屏蔽字

   ○资源限制

   ○控制终端

子进程独有的：

   ○进程号PID

   ○不同的父进程号

   ○自己的文件描述符和目录流的拷贝

   ○子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）

   ○不继承异步输入和输出 



父进程：

子进程：由父进程使用fork()系统调用创建。

**联系：**

创建子进程作为父进程的副本；子进程继承父进程大部分的属性。

子进程与父进程拥有相同内容的代码段、数据段和用户堆栈，目录。

**区别**：

子进程拥有自己的进程号PID，拥有独立的地址空间，自己的文件描述符和目录流的拷贝





### 1.1.9 什么是进程上下文，中断上下文

**进程上下文**：

​	一个进程在执行的时候，CPU中的所有寄存器中的值，进程的状态以及堆栈中的内容，当需要切换到另外一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次运行此进程时，能够恢复切换前的状态。

​	切换到内核态后执行的程序，即运行在内核空间的部分。



**中断上下文：**

​	由硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文可以理解为硬件传递过来的这些参数和内核需要保存的一些环境。

​	当用户进程想要访问系统资源，必须通过系统调用或者中断切换到内核态，由内核执行。









## 1.2 并发、同步、异步、互斥、阻塞、非阻塞的理解





### 1.2.1 并发、同步、异步、互斥、阻塞、非阻塞的概念

**并发**：两个或多个事件在同一时间间隔发生，就是微观上交替发生，宏观上同时发生。

**同步**：两个或多个进程的运行必须按照严格的先后顺序进行

**互斥**：对于某些临界资源的访问，需要互斥的进行，同一时段只允许一个进程访问该资源。

**异步**：异步彼此独立，不需要等待某个事件的发生才能工作

**注意：**

1）线程是实现异步的一个方式。可以在主线程创建一个新线程来做某件事，此时主线程不需等待子线程做完而是可以做其他事情。

2）异步和多线程并不是一个同等关系。异步是最终目的,多线程只是我们实现异步的一种手段。

**阻塞**：指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

**非阻塞**：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。



一般来说可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。

**同步阻塞**：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果就一直等待，等待期间不做任何操作。

**同步非阻塞**：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果，就立即返回，接收方继续做他事情，此时并未响应发送方，发送发就一直等待，直到接收方读取结果响应发送方，接收方才可以进入下一次请求。

**异步阻塞**：发送方发出请求后，不等待响应，继续其他工作（异步），接收方开始读取文件，如果不能马上得到读取结果就一直等待，等待期间不做任何操作。

**异步非阻塞**：发送方发出请求后，不等待响应，继续其他工作（异步），接收方读取文件如果不能马上得到结果，也不等待，而是马上返回取做其他事情。当IO操作（读取文件）完成以后，将完成状态和结果通知接收方，接收方在响应发送方。（效率最高）

**总结：** 

1）同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。

2）阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。

3）阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。



### 1.2.2 什么是线程同步和互斥

线程同步：线程之间的一种制约关系，一个线程依赖另一个线程的消息，每个线程都按照约定的先后次序运行

线程互斥：针对共享的临界资源，同一时段只允许一个线程访问资源，直到占用资源者释放资源后，其他线程才可以访问。





### 1.2.3 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？

**同步是一个过程，阻塞是一种状态。**

**线程同步不一定发生阻塞**，线程同步时，只有两个资源出现相互等待和相互唤醒时才会出现阻塞。











## 1.3 孤儿进程、僵尸进程、守护进程的概念







### 1.3.1 基本概念

**孤儿进程**：当父进程退出时，子进程仍然在运行，则子进程就是孤儿进程。

**僵尸进程**：子进程退出后，父进程没有调用wait()函数接收结束子进程，子进程停留在系统中，这就是僵尸进程。

**守护进程**：守护进程不受终端影响，退出终端也可以运行。



### 1.3.2 如何创建守护进程

1）**创建子进程，退出父进程**。利用`fork()`函数。

2）**创建新会话，摆脱终端影响**。利用`setsid()`函数创建新会话，并担任该会话组的组长，摆脱原会话的控制==>摆脱原进程的控制==>摆脱原控制台的控制。

3）**改变守护进程的工作目录为根目录**。利用`chrdir()`函数改变目录。

4）**重设文件权限掩码**。子进程继承了父进程的权限掩码，通过`umask()`函数屏蔽掉文件权限中的对应位，需要将子进程置零，拥有较大权限，提高守护进程灵活度。

5）**关闭不需要的文件描述符**。从父进程继承的文件描述符，不需要的可以关闭。

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>

int main()
{
        pid_t pid;
        int fd,len,i,num;
        char *buf="the dameon is running\n";
        len =strlen(buf)+1;


        pid=fork();
        if(pid>0)
        {
                exit(0);
        }

        //创建新会话，摆脱终端影响
        setsid();

        //改变当前工作目录
        chdir("/");

        //重设文件权限掩码
        umask(0);
    
		//关闭不需要的文件描述符
        for(int i=0;i<3;i++)
        {
                close(i);
        }

        while(1)
        {
                fd=open("/var/log/dameon.log",O_CREAT|O_WRONLY|O_APPEND,0666);
                write(fd,buf,len);
                close(fd);
                sleep(5);
        }
        return 0;
}
```









### 1.3.2 正确处理孤儿进程、僵尸进程的方法

**孤儿进程的处理：**

​	孤儿进程会有linux系统中的1号进程init进程来处理，他利用wait()函数来处理已经退出的子程序

**僵尸进程的处理：**

​	如果父进程一直不调用wait/waitpid函数接收子进程，那么子进程就一直保存在系统里，占用系统资源，因此如果僵尸进程数量太多，那么就会导致系统空间爆满，无法创建新的进程，严重系统工作

​	系统规定，子进程退出后，父进程会自动收到SIGCHLD信号。因此我们需要在父进程里重置signal函数。每当子进程退出，父进程都会收到SIGCHLD信号，故通过signal函数，重置信号响应函数。

```c
void* handler(int sig)
{
    int status;
    if(waitpid(-1, &status, WNOHANG) >= 0)
    {
        printf("child is die\n");
    }
}
int main()
{
    signal(SIGCHLD, handler);
    int pid = fork();
    if(pid > 0)  //父进程循环等待
    {
        while(1)
        {
            sleep(2);
        }
    
    }else if(0 == pid){   //子进程说自己die后就结束生命周期，之后父进程就收到SIGCHLD
                          //信号调用handler函数接收结束子进程，打印child is die。
        printf("i am child, i die\n");
    }
}
```





```c
pid_t wait(int *status);
pid_t waitpid(pid_t pid,int *status,int options);
```

`wait()`:

​	成功返回`pid`，失败返回-1；

`status:`

WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）

WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）



`waitpid()`:

​	成功返回`pid`，失败返回-1；

`pid：`

​	pid=-1,等待任意一个子进程，和wait等效

​	pid>0:只等待进程id等于pid的进程

​	pid=0:等待同一进程组的任意一个进程，如果子进程加入其他进程组不加理会

​	pid<-1时，等待一个指定进程组中的任意一个进程，这个进程组的id就是pid的绝对值

`status:`

​	WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）

​	WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）

`options:`

​	WNOHANG:若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回孩子进程的进程id



waitpid有wait没有的三个功能：

（1）waitpid能等待一个特定的子进程，而wait只能等待任意的子进程，

（2）系统一旦调用wait函数就会阻塞父进程来等待，直到等到子进程的退出才停止阻塞，而waitpid提供了一种非阻塞方式的等待，也就是第三个参数，当第三个参数设置为WNOHANG，当子进程没有结束，直接返回0，不等待

（3）waitpid支持作业控制，提供用于检查wait和waitpid返回状态的宏这两个函数返回的子进程的状态都保存在status指针中

WIFEXITED(status): 若为正常终止, 则为真. 此时可执行 WEXITSTATUS(status): 取子进程传送给exit或_exit参数的低8位.

WIFSIGNALED(status): 若为异常终止, 则为真.此时可执行 WTERMSIG(status): 取使子进程终止的信号编号.

WIFSTOPPED(status): 若为当前暂停子进程, 则为真. 此时可执行 WSTOPSIG(status): 取使子进程暂停的信号编号









# 第二章 C/C++







## 2.1 c和c++区别、概念相关面试题



### malloc和free

```c
(int*)malloc(4);
// 申请了一个四个字节的空间并且规定该空间为一个int型变量空间，而不是别的。

int *p =(int*)malloc(4);
// 由于malloc返回一个 空间地址，所以需要一个相应类型的指针来接收改地址

int *p;
p=(int*)malloc(4);
//也可以分写
```

```c
//堆区申请内存
int *p=malloc(sizeof(int)*5);  //申请了5个int类型的空间

//栈区申请内存
int a[5];
int *p=&a[0];

free(p);
```











### **2.1.1 new和malloc的区别**

1. new、delete是C++中独有的操作符，而malloc和free是C/C++中的标准库函数

2. 使用new创建对象在分配内存时会自动调用构造函数，同时完成对象的初始化。delete可以自动调用析构函数。

   malloc和free是库函数不是运算符，不能自动调用构造函数和析构函数。malloc只是单纯地为变量分配内存，free只是释放变量的内存。

3. new返回的是指定类型的指针，并可以自动计算所申请的内存大小。

   malloc返回的是void*类型，需要强行将其转换为实际类型的指针，并指定要申请内存的大小。

4. C++允许重载new/delete，而malloc和free是函数不可以重载

5. new分配内存失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL

6. 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。

   new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。







### **2.1.2 malloc的底层实现**

​	Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。我们用malloc进行内存分配就是从break往上进行的。

![img](https://s2.loli.net/2022/06/27/OBo16q5YmIlzETX.png)

malloc函数的实质是将一个可用的内存块链接为一个长长的空闲分区链表。调用malloc()函数时，它沿着链接表寻找一个大到足以满足用户需求的内存块。然后将内存块划分出用户申请的大小，将剩余部分返回到链接表。

free函数，将用户释放的内存空间连接到空闲链表。

​	 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。







### **2.1.3在1G内存的计算机中能否malloc(1.2G)？为什么？**

可以。

malloc函数向操作系统申请一块逻辑地址，与物理地址无直接联系。操作系统利用虚拟内存原理，完成逻辑地址与物理地址的转换。操作系统负责将信息从外存与内存之间调入调出，从而容纳超出内存大小的信息。







### **2.1.4指针与引用的相同和区别；如何相互转换？⭐⭐⭐⭐⭐**

**相同：都是地址的概念**

指针指向一块内存，它的内容是所指变量的地址。引用是某块内存的别名。

从内存来看，两者都占据内存。在32位系统中，指针一般占据4字节内存。引用为指针常量，无法使用sizeof查看其大小

**区别：**

1. 指针是一个实体，引用仅仅是别名；
2. 指针和引用的自增运算意义不同。指针是内存地址的自增，引用是变量值的自增；
3. 指针需要使用解除引用运算符。引用不需要
4. 引用只能在定义时进行初始化。指针可变。
5. 引用不能为空，指针可以为空
6. 引用没有const (int & const a),指针有const(int * const a：此指针不能改变其所指的变量)
7. sizeof 引用 得到是变量的大小；sizeof 指针 得到的是指针本身的大小

**引用和指针之间怎么转换**

1. 指针转引用：指针使用接触引用运算符就可以转换为对象

   ```c++
   void fun(int &val){}
   fun(*pA);
   ```

2. 引用转指针：引用类型的对象使用&取地址符，就可以获得指针

   ```c++
   int a=0;
   int *pA = &a;
   ```

   





### 2.1.5 C语言检索内存情况 内存分配的方式

检索内存：对某段内存进行遍历搜索

内存分配：

1. 静态存储区域分配。内存在程序编译时就已经分配好。如全局变量，常量，静态变量。
2. 栈。函数内局部变量的存储单元可以在栈上创建，函数执行结束时这些存储单元自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
3. 堆。动态内存分配。程序员需要自己申请动态内存并且释放内存。动态内存的生存期由程序员决定，若分配了空间未收回，则会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。











### 2.1.6  extern”C” 的作用⭐⭐⭐

**extern "C"**是C++特有的指令（C无法使用该指令），目的在于支持C++与C混合编程。

**extern “C”**的作用是告诉**C++编译器**用C规则编译指定的代码（除函数重载外，**extern “C”**不影响C++其他特性）。

**因为C和C++的编译规则不一样，主要区别体现在编译期间生成函数符号的规则不一致**

```c++
//func.h c文件
void func(int set);


//main.cpp c++文件
//法一:
extern "C"{
    #include "func.h"
}

//法二:
#include "func.h"
extern "C" void func(int set);
```





### 2.1.7头文件声明时加extern定义时不要加 因为extern可以多次声明，但只有一个定义⭐⭐⭐⭐

对于外部链接的变量，函数。extern修饰符用在变量和函数的声明前，说明此变量函数的定义在别处，且定义只有一个，此处引用声明。

**extern在链接阶段起作用。**







### 2.1.8函数参数压栈顺序，即关于`__stdcall`和`__cdecl`调用方式的理解⭐⭐⭐

`__stdcall`和`__cdecl`都是函数调用约定关键字，我们先来看看`__stdcall`和`__cdecl`调用方式的概念：

1）`__stdcall`是C++的标准调用方式，参数由右向左压入栈，函数在返回时会自动清除堆栈中的参数

2）`__cdecl`是C语言默认的函数调用方式，参数由右向左压入栈，函数在返回时不会自动清除堆栈中的参数，清除工作由调用者完成。

```c++
int __stdcall Func_stdcall(int nParam1, int nParam2)  
{  
    return 1;  
}  
int __cdecl Func_cdecl(int nParam1, int nParam2)  
{  
    return 1;  
}  
```









### 2.1.9重写memcpy()函数需要注意哪些问题⭐⭐

从存储区 str2 复制 n 个字节到存储区 str1。

```
 void *memcpy(void *str1, const void *str2, size_t n) 
```

- **str1** -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
- **str2** -- 指向要复制的数据源，类型强制转换为 void* 指针。
- **n** -- 要被复制的字节数。



情况一：两个数组不会重叠，从前至后赋值。

情况二：源地址数组在目标地址前，且两数组重叠，从后至前赋值。

情况三：源地址数组在目标地址后，且两数组重叠，从前至后赋值。

```c
 void *memcpy(void *str1, const void *str2, size_t n) 
 {
     char* pstr1;
     char* pstr2;
     if(str1==NULL||str2==NULL)
     {
         return NULL;
     }
     
     if(str2<str1 && ((char*)str2+n> (char*)str1))
     {
         pstr1=(char*)str1+n-1;
         pstr2=(char*)str2+n-1;
         while(n--)
         {
             *pstr1--=*pstr2--;
         }
     }else
     {
         pstr1=(char*)str1;
         pstr2=(char*)str2;
         while(n--)
         {
             *pstr1++=*pstr2++;
         }
     }
     return str1;
 }
```





### 2.1.10数组到底存放在哪里⭐⭐⭐

1. 定义在全局下的全局变量，就是在数据段里
2. 定义在函数下的局部变量，数组存放在函数调用栈里
3. 程序员使用new申请的动态内存，就是存放在自由存储区里
4. 固定数组在类中分配是在堆中







### 2.1.11  struct和class的区别 ⭐⭐⭐⭐⭐

区别：struct的默认访问控制为public；class的默认访问控制为private









### **2.1.12 char和int之间的转换；⭐⭐⭐**

从四字节的int转换为带符号位的char，取int的最低的一个字节，将其赋给char型数据，且第一位为符号位。

从四字节的int转换为unsigned char，取int的最低的一个字节，将其赋给char型数据，第一位无符号位，则整个字节都是数据。

从char转换为int：将前面三个字节补齐，char首位为1，补上0xfff，char首位为0，补上0x000

从unsigned char转换为int：前三个字节补上0x000





### **2.1.13  static的用法（定义和用途）⭐⭐⭐⭐⭐**

static作用：改变生命周期和改变作用域

static局部变量：**将局部变量由自动存储方式变为静态存储方式**，在程序运行时就为其分配内存，函数执行结束，仍继续保留在内存中。

static全局变量：**改变全局变量的外部链接性为内部链接性，**只在本文件内使用，无法在其他文件中使用。

static函数：**改变函数的外部链接性为内部链接性，**使得函数只在本文件内部有效，对其他文件是不可见的。这样的函数又叫作**静态函数。**

static成员变量：这个成员为全类所共有，类的所有对象都共用一个此成员。

static成员函数：这个函数为全类所共有，**只能访问静态成员变量**





### **2.1.14  cosnt的用法（定义和用途）⭐⭐⭐⭐⭐**

const是常量修饰符，const变量应该在声明的时候就进行初始化，如果在声明变量的时候没有提供值，则该常量值是不确定的，且无法修改。

const修饰主要用来修饰变量，函数形参，函数返回值和类成员函数

1）const变量：定义时就初始化

2）const函数形参：该形参在函数里不能改变

3）const函数返回值：该返回值不能作为左值

4）const类成员函数：在整个函数中不能修改成员变量的值





### **2.1.15 const常量和#define的区别（编译阶段、安全性、内存占用等） ⭐⭐⭐⭐**

**编译阶段**：#define是在编译的**预处理阶**段起作用的；const是在**编译**阶段确定其值的

**作用方式**：#define只是简单的字符替换，没有**类型检查**；const是有**对应的类型的**

**内存占用**：#define所定义的宏变量在内存中有**多个拷贝**；const定义的变量**只有一个拷贝**

**函数作用**：#define可以定义一些函数，const不可以定义函数

**代码调试**：#define在预处理阶段替换，无法调试；const变量可以调试

**作用范围**：#define的作用范围为当前文件；const变量默认的作用范围也是文件内，但是可以使用extern关键字，将其链接性改为外部。

**指针指向**：#define定义常量不能用指针指向；const常量可以用指针指向其地址。



### **2.1.16  volatile作用和用法 ⭐⭐⭐⭐⭐**

​	使用volatile关键字声明的变量或对象通常具有与优化、多线程相关的特殊属性。通常, volatile 关键字用来阻止(伪)编译器认为的无法“被代码本身"改变的代码(变量/对象)进行优化。如在C语言中,**volatile关键字可以用来提醒编译器它后面所定义的变量随时有可能改变,因此编译后的程序每次需要存储或读取这个变量的时候,都会直接从变量地址中读取数据。**如果没有volatile关键字,则编译器可,能优化读取和存储,可能暂时使用寄存器中的值,如果这个变量由别的程序更新了的话,将出现不致的现象。

总结：

**优点：防止编译器对代码优化，变量值是直接从变量地址中读取和存储的。**

缺点：这种使用过多会导致代码十分庞大。



```c++
int i=0;
int main(void)
{
     ...
     while (1){
        if (i) dosomething();
     }
｝

/* Interrupt service routine. */
void ISR_2(void)
{
      i=1;
}
```

​	程序的本意是希望ISR_2中断产生时，在main函数中调用dosomething函数。但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果**将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）**。此例中i也应该是**volatile int i**；





### **2.1.17有常量指针 指针常量 常量引用 没有 引用常量⭐⭐⭐**

**常量指针**

```c++
//指针指向的是一个常量，不可以通过指针改变变量的值
const int *p=&a;
int const *p=&a;
```

**指针常量**

```c++
//指针本身的指向不能变
int * const p=&a;
```

**常量引用**

```c++
//不可以通过常量引用r来改变a，可以使用常量引用指向常量
const int &r=a;
const int &r=10;
```





### **2.1.18没有指向引用的指针，因为引用是没有地址的，但是有指针的引用⭐⭐⭐**

指针本质是指向某一块内存空间的，而引用是变量的别名，本身没有地址。所以**没有指向引用的指针**，**如果创建指针指向引用其实是指向引用的对象**。

```c++
int a;
int &r=a;
int *p=&r;//指针p指向的是变量a
```





### **2.1.19c/c++中变量的作用域⭐⭐⭐⭐⭐**

**全局变量：**全局变量是在函数体的外部定义的，程序所在部分都可以使用。全局变量不受作用域影响，其生命周期直到整个程序结束

**局部变量**：局部变量出现在一个作用域内，局限于一个函数。存储在栈中，函数调用结束后，自动释放变量

**寄存器变量**：寄存器变量是一种局部变量，关键字register告诉编译器尽可能快的访问这个变量，访问速度取决于现实。

**静态变量**：关键字static。静态局部变量，可以使变量的生命周期延长至整个程序，但是其作用域不变，函数调用之间这个变量的值不变。静态全局变量，改变了变量的作用域，仅在定义他的文件中使用，不能作用到其他文件里。

**外部变量**：extern关键字告诉编译器，当前变量和函数其定义存在某个文件中，此处只做声明引用

**const常量**：const变量的值是确定值，全局不可以修改，其在定义时必须初始化。

**volatile变量**：限定词volatile则告诉编译器“不知道何时变化”，防止编译器依据变量的稳定性作任何优化。







### **2.1.20** **c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？⭐⭐⭐⭐**

**（1）static_cast**

**static_cast< new_type >(expression)**

静态转换，在编译处理阶段

用于C++内置的基本数据类型转换，将expression转换为new_type,但是不能保证转换的安全性

- ①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。

  进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；

  进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。

- ②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。

- ③把空指针转换成目标类型的空指针。

- ④把任何类型的表达式转换成void类型。

  注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性

```c++
char a = 'a';
int b = static_cast<int>(a);//正确，将char型数据转换成int型数据

double *c = new double;
void *d = static_cast<void*>(c);//正确，将double指针转换成void指针

int e = 10;
const int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据

const int g = 20;
int *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性
```

```c++
High bar;
Low blow;
High *pb=static_cast<High*>(&blow);
Low *pl=static_cast<Low*>(&bar);
```



**（2）const_cast**

特点：去常转换，编译时执行。不是运行时执行

应用场合：const_cast操作不能在不同的种类间转换。相反，它仅仅把它作用的表达式转换成常量。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。 

const_case只能转换**指针或引用** 不能转换变量

去掉const属性：`const_cast<int*> (&num)`，常用，因为**不能把一个const变量直接赋给一个非const变量，必须要转换。**

```c++
//const_cast中的类型必须是引用或者指针
const_cast<type-name>(expression);
const int a = 5;
int r = const_cast<int&>(a);
int *r= const_cast<int*>(a);
```



**（3）reinterpret_cast**

特点： 重解释类型转换

应用场合：它有着和c风格强制类型转换同样的功能；它可以转化任何的内置数据类型为其他的类型，同时它也可以把任何类型的指针转化为其他的类型；它的机理是对二进制进行重新的解释，不会改变原来的格式。



**（4）dynamic_cast <type_id > ( expression )**

dynamic_cast主要用于类层次间的**上行转换**和**下行转换**，还可以用于**类之间的交叉转换**（cross cast）。

上行转换时和static_cast效果一样，下行转换时，具有检测功能，比static_cast更安全。

type_id必须是**类的指针，类的引用或者空类型的指针**，expression必须也是相对应的类型。

如果转换目标是指针类型并且失败了，则结果为0。

如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常

```c++
High* ph;
Low* pl;
pl=dynamic_cast<Low*>ph;//仅当Low是High可访问的基类，才能赋值，否则将空指针付给pl
Hight & ph1=dynamic_cast<low&>(*pl1);
```



### 2.1.21 对 c++ 中的智能指针的理解

​	C++里面的四个智能指针:`auto_ptr,shared_ptr,weak_ptr,unique_ptr`，其中后三个是c++11支持，并且第一个已经被11弃用。

​	智能指针的作用：智能是一个类，通过智能指针申请空间时，在其作用域结束时，会自动调用析构函数，从而释放空间，无需手动释放内存空间。

- `auto_ptr`

```c++
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr不会报错.
```

​	此 时 不 会 报 错 ， p 2 剥 夺 了 p 1 的 所 有 权 ， 但 是 当 程 序 运 行 时 访 问 p 1 将 会 报 错 。 所 以 a u t o _ p t r 的 缺 点 是 ： 存 在 潜 在 的 内 存 崩 溃 问 题 



- `unique_ptr`

  `unique_ptr`实现独占式拥有，保证同一时间内只有一个智能指针指向该对象。

```c++
unique_ptr<string> p3 (new string ("auto")); //#4
unique_ptr<string> p4； //#5
p4 = p3;//此时会报错！！
```

​	编 译 器 认 为 p 4 = p 3 非 法 ， 避 免 了 p 3 不 再 指 向 有 效 数 据 的 问 题 。 因 此 ， u n i q u e _ p t r 比 a u t o _ p t r 更 安 全 。

```c++
unique_ptr<string> pu1(new string("hello world!"));
unique_ptr<string> pu2;
pu2=pu1;		// #1 not allowed
unique_ptr<string> pu3;
pu3=unique_ptr<string>(new string("You"));	//#2 allowed
```

​	其 中 # 1 留 下 悬 挂 的 u n i q u e _ p t r ( p u 1 ) ， 这 可 能 导 致 危 害 。 而 # 2 不 会 留 下 悬 挂 的 u n i q u e _ p t r ， 因 为 它 调 用 u n i q u e _ p t r 的 构 造 函 数 ， 该 构 造 函 数 创 建 的 临 时 对 象 在 其 所 有 权 让 给 p u 3 后 就 会 被 销 毁 。 这 种 随 情 况 而 已 的 行 为 表 明 ， u n i q u e _ p t r 优 于 允 许 两 种 赋 值 的 a u t o _ p t r 。

​	注 ： 如 果 确 实 想 执 行 类 似 与 # 1 的 操 作 ， 要 安 全 的 重 用 这 种 指 针 ， 可 给 它 赋 新 值 。 C + + 有 一 个 标 准 库 函 数 s t d : : m o v e ( ) ， 让 你 能 够 将 一 个 u n i q u e _ p t r 赋 给 另 一 个 。 例 如 ：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```



- `shared_ptr`

​	s h a r e d _ p t r 实 现 共 享 式 拥 有 概 念 。 多 个 智 能 指 针 可 以 指 向 相 同 对 象 ， 该 对 象 和 其 相 关 资 源 会 在 “ 最 后 一 个 引 用 被 销 毁 ” 时 候 释 放 。 从 名 字 s h a r e 就 可 以 看 出 了 资 源 可 以 被 多 个 指 针 共 享 ， 它 使 用 计 数 机 制 来 表 明 资 源 被 几 个 指 针 共 享 。 可 以 通 过 成 员 函 数 u s e _ c o u n t ( ) 来 查 看 资 源 的 所 有 者 个 数 。 除 了 可 以 通 过 n e w 来 构 造 ， 还 可 以 通 过 传 入 a u t o _ p t r , u n i q u e _ p t r , w e a k _ p t r 来 构 造 。 当 我 们 调 用 r e l e a s e ( ) 时 ， 当 前 指 针 会 释 放 资 源 所 有 权 ， 计 数 减 一 。 当 计 数 等 于 0 时 ， 资 源 会 被 释 放 。

- 成员函数
  - u s e _ c o u n t 返 回 引 用 计 数 的 个 数
  - u n i q u e 返 回 是 否 是 独 占 所 有 权 ( u s e _ c o u n t 为 1 )
  - s w a p 交 换 两 个 s h a r e d _ p t r 对 象 ( 即 交 换 所 拥 有 的 对 象 ) 
  - r e s e t 放 弃 内 部 对 象 的 所 有 权 或 拥 有 对 象 的 变 更 , 会 引 起 原 有 对 象 的 引 用 计 数 的 减 少



- `weak_ptr`

w e a k _ p t r 是 一 种 不 控 制 对 象 生 命 周 期 的 智 能 指 针 , 它 指 向 一 个 s h a r e d _ p t r 管 理 的 对 象 . 进 行 该 对 象 的 内 存 管 理 的 是 那 个 强 引 用 的 s h a r e d _ p t r . w e a k _ p t r 只 是 提 供 了 对 管 理 对 象 的 一 个 访 问 手 段 。 w e a k _ p t r 设 计 的 目 的 是 为 配 合 s h a r e d _ p t r 而 引 入 的 一 种 智 能 指 针 来 协 助 s h a r e d _ p t r 工 作 , 它 只 可 以 从 一 个 s h a r e d _ p t r 或 另 一 个 w e a k _ p t r 对 象 构 造 , 它 的 构 造 和 析 构 不 会 引 起 引 用 记 数 的 增 加 或 减 少 。 w e a k _ p t r 是 用 来 解 决 s h a r e d _ p t r 相 互 引 用 时 的 死 锁 问 题 , 如 果 说 两 个 s h a r e d _ p t r 相 互 引 用 , 那 么 这 两 个 指 针 的 引 用 计 数 永 远 不 可 能 下 降 为 0 , 资 源 永 远 不 会 释 放 。 它 是 对 对 象 的 一 种 弱 引 用 ， 不 会 增 加 对 象 的 引 用 计 数 ， 和 s h a r e d _ p t r 之 间 可 以 相 互 转 化 ， s h a r e d _ p t r 可 以 直 接 赋 值 给 它 ， 它 可 以 通 过 调 用 l o c k 函 数 来 获 得 s h a r e d _ p t r 。

```c++
class B;
class A
{
public:
	shared_ptr<B> pb_;
	~A(){cout<<"A delete";}
};

class B
{
public:
	shared_ptr<A> pa_;
	~B(){ cout<<"B delete";}
};

void fun()
{
     shared_ptr<B> pb(new B());
     shared_ptr<A> pa(new A());
     pb->pa_ = pa;
     pa->pb_ = pb;
     cout<<pb.use_count()<<endl;
     cout<<pa.use_count()<<endl;
}

int main()
{
     fun();
     return 0;
}
```

​	可 以 看 到 f u n 函 数 中 p a ， p b 之 间 互 相 引 用 ， 两 个 资 源 的 引 用 计 数 为 2 ， 当 要 跳 出 函 数 时 ， 智 能 指 针 p a ， p b 析 构 时 两 个 资 源 引 用 计 数 会 减 一 ， 但 是 两 者 引 用 计 数 还 是 为 1 ， 导 致 跳 出 函 数 时 资 源 没 有 被 释 放 （ A B 的 析 构 函 数 没 有 被 调 用 ） ， 如 果 把 其 中 一 个 改 为 w e a k _ p t r 就 可 以 了 ， 我 们 把 类 A 里 面 的 s h a r e d _ p t r p b _ ; 改 为 w e a k _ p t r p b _ ; 运 行 结 果 如 下 ， 这 样 的 话 ， 资 源 B 的 引 用 开 始 就 只 有 1 ， 当 p b 析 构 时 ， B 的 计 数 变 为 0 ， B 得 到 释 放 ， B 释 放 的 同 时 也 会 使 A 的 计 数 减 一 ， 同 时 p a 析 构 时 使 A 的 计 数 减 一 ， 那 么 A 的 计 数 为 0 ， A 得 到 释 放 。 

​	注 意 ： 不 能 通 过 w e a k _ p t r 直 接 访 问 对 象 的 方 法 ， 比 如 B 对 象 中 有 一 个 方 法 p r i n t ( ) , 我 们 不 能 这 样 访 问 ， p a - > p b _ - > p r i n t ( ) ; 英 文 p b _ 是 一 个 w e a k _ p t r ， 应 该 先 把 它 转 化 为 s h a r e d _ p t r , 如 ： s h a r e d _ p t r p = p a - > p b _ . l o c k ( ) ; p - > p r i n t ( ) ;







### 2.1.22 设计一个不能被继承的类

```c++
template <typename T>
clsss A
{
    friend T;
private:
    A(){};
    ~A(){};
}

class B:virtual public A<B>
{
public:
    B(){};
    ~B(){};
}

class C:virtual public B
{
public:
    C(){};
    ~C(){};
}

void main(void)
{
    B b;
    C c;//报错
}
```

A类的构造函数为私有，所以访问A类必须是其友元函数，将模板参数设置为B类对象，构造B类对象时，可以直接访问父类A类的构造函数。

由于为虚继承，所以创建C对象时，不仅需要调用B类的构造函数还需要调用A类的构造函数，由于C没有访问A构造函数的权限，所以编译器就会报错。









## 2.2  继承与多态相关面试题



### **2.2.1继承和虚继承 ⭐⭐⭐⭐⭐**

**继承**：从一个基类派生出一个派生类称为继承

**虚基类**：虚基类是从多个类（他们的基类相同）派生出的对象只继承一个基类对象。

```c++
class Singer:virtual public Worker{};
class Waiter:public virtual Worker{};
class SingingWaiter:public singer,public Waiter{}
//singerWaiter只包含一个worker子对象
```

对于虚基类来说，自动传递将不起作用，需要显示调用虚基类的构造函数

```c++
SingingWaiter(const Worker &wk,int p=0,int v=Singer::other):Waiter(wk,p),Singer(wk,v){}
//C++基类是虚的，禁止信息从中间类传递给基类。
//在上述情况下，编译器将使用worker的默认构造函数
SingingWaiter(const Worker &wk,int p=0,int v=Singer::other):Worker(wk),Waiter(wk,p),Singer(wk,v){}
//显示调用构造函数worker(const Worker&)
```





### **2.2.2多态的类，内存布局是怎么样的 ⭐⭐⭐⭐⭐**

（1）虚继承：如果是虚继承，那么就会为这个类创建一个虚表指针，占用4个字节

```c++
#include <stdio.h>  
class A {  
public:  
    int a;  
}; //sizeof(A)=4，因为a是整形，占用4字节

class B : virtual public A {  
public:  
    int b;  
};//sizeof(B)=4(A副本)+4(虚表指针占用4字节)+4(变量b占用4字节)=12  

class C : virtual public B {       
};//sizeof(c)= 12(B副本)+4(虚表指针) = 16，如果这里改为直接继承，那么sizeof(c)=12，因为此时就没有虚表指针了
```

（2）多重继承：如果是以**虚继承**实现多重继承，记得减掉基类的副本

```c++
#include <stdio.h>  
class A {  
public:  
    int a;  
};//sizeof(A) = 4  

class B : virtual public A {  
};// sizeof(B) =4+4=8  

class C : virtual public A {          
};//sizeof(C) =4+4=8  

class D : public B, public C{         
};  
//sizeof(D)=8+8-4=12这里需要注意要减去4，因为B和C同时继承A，只需要保存一个A的副本就好了，sizeof(D)=4(A的副本)+4(B的虚表)+4(C的虚表)=12，也可以是8（B的副本）+8（c的副本）-4（A的副本）=12
```

（3）普通继承（含有：空类、虚函数）

```c++
class A      //result=1  空类所占空间的大小为1  
{     
};    

class B     //result=8  1+4   字节对齐后为 8  
{  
    char ch;     
    virtual void func0()  {  }   
};   

class C    //result=8  1+1+4 字节对齐后为 8，没有继承的，此时类里即使出现多个虚函数，也只有一个虚指针
{  
    char ch1;  
    char ch2;  
    virtual void func()  {  }    //也只有一个虚指针
    virtual void func1() {  }    //也只有一个虚指针
};  
  
class D: public A, public C  //result=12  8（C的副本）+4（整形变量d占用4字节）=12  
{     
    int d;     
    virtual void func()  {  }   //继承了C，C里已经有一个虚指针，此时D自己有虚函数，
    virtual void func1()  {  } //也不会创建另一个虚指针，所以D本身就变量d需要4字节
};     
  
class E: public B, public C  //result=20   8（ B的副本）+8（C的副本）+4（E本身）=20
{     
    int e;     
    virtual void func0()  {  }   //同理，E不会创建另一个虚指针，所以E本身就变量e需
    virtual void func1()  {  }  //要4字节
};  
```

 （4）虚继承（多重继承和虚函数）

```c++
class CommonBase  
{  
    int co;  
};// size = 4  
  
class Base1: virtual public CommonBase            
{  
public:  
    virtual void print1() {  }  
    virtual void print2() {  }  
private:  
    int b1;  
};//4（父类副本）+4（自己有虚函数，加1个虚指针空间）+4（自身变量b1）+4(虚继承再加1个虚指针空间)=16  

class Base2: virtual public CommonBase          
{  
public:  
    virtual void dump1() {  }  
    virtual void dump2() {  }  
private:  
    int b2;  
};//同理16  
  
class Derived: public Base1, public Base2       
{  
public:  
    void print2() {  }  
    void dump2() {  }  
private:  
    int d;  
};//16+16-4+4=32  
```

如果此时类里有一个或多个虚函数，那么需要加1个虚指针空间，如果还是虚继承，那么需要再加1个虚指针空间，最多就2个虚指针空间。

（5）虚继承与虚函数

```c++
class A  
{  
public:  
    virtual void aa() {  }  
    virtual void aa2() {  } //如果此时类里有一个或多个虚函数，那么需要加1个虚指针空间
private:  
    char ch[3];  
}; // 1+4 =补齐= 8   
  
class B: virtual public A //如果还是虚继承，那么需要再加1个虚指针空间，最多就2个虚指//针空间。
{  
public:  
    virtual void bb() {  }  
    virtual void bb2() {  }  
}; // 8（副本）+4(虚继承)+4（虚指针）= 16  
```





### **2.2.3被隐藏的基类函数如何调用   或者  子类调用父类的同名函数和父类成员变量 ⭐⭐⭐⭐⭐**

1）使用using关键字，调用父类同名函数

```c++
class child:public parent
{
	Child(){};
    using parent::add;
    int add(void){};
}
```

2）使用作用域操作符，调用基类中被隐藏的所有成员函数和变量

```c++
Child a;
a.add();
a.Parent::add();
```





### **2.2.4多态实现的三个条件、实现的原理 ⭐⭐⭐⭐⭐**

**条件：**

1. 继承
2. 虚函数重写
3. 父类指针指向子类对象

**实现原理：**

1、基类中的虚函数

​	类中若定义了虚函数，那么类会多出一个成员指针，称为**虚函数指针**，虚函数指针指向一张虚函数表，**虚函数表中存放的是类中的每一个虚函数地址**，注意非虚函数的成员函数不会放入虚函数表中

2、继承

​	子类继承父类，那么子类会继承除了构造函数和析构函数的所有成员，当然也会继承父类的虚函数指针和虚函数表，可以看做子类的构成中有一个父类

3、重写子类的虚函数 以及子类指针或引用赋值给父类

​	在重写子类的虚函数后，子类的虚函数地址与父类对应的虚函数地址会有不同，**在子类指针或引用赋值给父类时，虚函数表中原先父类的虚函数地址会被重写的子类的虚函数地址覆盖掉**，从而完成不同的子类指针或引用赋值给同一父类指针或引用时，在调用父类的虚函数时回去调用对应子类的虚函数，最终实现多态。

​	注意若在子类定义了父类不具有的虚函数，这个虚函数也会加入子类继承而来的虚函数表中，但是不能通过父类指针或引用去调用这个父类不具有的虚函数，即子类指针或引用赋值给父类后，父类指针或引用的作用范围不能超过父类的成员范围





### **2.2.5对拷贝构造函数 深浅拷贝 的理解 拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？⭐⭐⭐**

**默认拷贝构造函数**，逐个复制非静态成员，对于某些使用new初始化的指针成员，以及字符串成员，仅能复制指向字符串的指针

**深度拷贝**：拷贝函数复制字符串并将副本的地址赋给新成员，而不是仅仅复制字符串地址

**自定义拷贝构造函数**：凡是**包含动态分配成员**或**包含指针的类**都应提供拷贝构造函数





### **2.2.6析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？⭐⭐⭐**

C++标准指明**析构函数不能，也不应该抛出异常。**C++异常处理模型有责任清除那些由于出现异常所导致的失效的对象，并释放对象原来分配的资源。所以析构函数已经变成了异常处理的一部分。

1）如果析构函数抛出异常，则异常之后的程序不会执行，如果异常点后的程序涉及释放资源等，则会造成资源泄露的问题

2）通常异常发生时，会调用析构函数来释放资源，若此时析构函数又抛出异常，则会造成程序的崩溃。







### **2.2.7什么情况下会调用拷贝构造函数（三种情况）⭐⭐⭐**

1. 一个对象以值传递的方式传入函数体
2. 一个对象以值传递的方式从函数返回
3. 对象通过另一个对象进行初始化







### **2.2.8析构函数一般写成虚函数的原因⭐⭐⭐⭐⭐**

在实现多态时，基类指针指向子类对象时，如果析构函数为虚函数，如果删除基类指针，则会调用基类指针指向的子类析构函数，而子类的析构函数又会自动调用基类的析构函数，这样整个子类对象都会被完全释放。

如果不讲析构函数声明为虚函数，则编译器实现静态绑定，删除基类指针时，只会调用基类的析构函数，不会调用子类的析构函数，对子类对象析构不完全。







### **2.2.9构造函数为什么一般不定义为虚函数⭐⭐⭐⭐⭐**

1）**从存储空间来看**：虚函数对应虚函数表的指针，而指向虚函数表的指针事实上是存储在对象的存储空间中。如果构造函数是虚的，就必须通过虚函数表来调用，但是对象没有实例化，内存空间也没有虚函数表，所以构造函数不能是虚函数

2）**使用角度来看**：虚函数的作用在于通过父类的指针或引用调用子类的成员函数。而构造函数在创建对象时自己主动调用，不可能通过父类的指针或引用去调用。

3）**从实现上看**：在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。



### **2.2.10什么是纯虚函数⭐⭐⭐⭐⭐**

纯虚函数：virtual 函数类型 函数名（参数列表）=0；

C++利用纯虚函数提供未实现的函数。纯虚函数不能被调用，其作用是在基类中为派生类保留一个函数的名字，以便派生类对其进行定义。

1. 纯虚函数没有函数体
2. 纯虚函数声明部分最后面有“=0”

凡是含有纯虚函数的类都是抽象类，抽象类是不能实例化的。抽象基类的作用是提供公共接口，派生类只有重新定义后才可以实例化出对象。





### **2.2.11静态绑定和动态绑定的介绍⭐⭐⭐⭐**

静态联编：在编译过程中进行联编

动态联编：编译器必须生成能够在程序运行时选择正确的虚方法的代码

非虚函数使用静态绑定，虚函数使用动态绑定



问题：引用是否能实现动态绑定，为什么引用可以实现 

答：只有指定为虚函数的成员函数才能进行动态绑定，且必须通过基类类型的引用或指针进行函数调用，而指针或引用是在运行期根据他们绑定的具体对象确定。



### **2.2.12 C++所有的构造函数 ⭐⭐⭐**

默认构造函数

拷贝构造函数

构造函数



### **2.2.13重写、重载、覆盖的区别⭐⭐⭐⭐⭐**

重写（覆盖）和重载的区别

- 重写和被重写的函数在子类和父类之间，重载和被重载的函数在一个类中

- 重写和被重写的函数的参数列表相同，重载和被重载的函数的参数列表不相同

- 重写的基类中被重写的函数必须有virtual修饰，重载的函数无要求

- 重写是运行时的多态性，重载是编译时的多态性

- 重写要求返回类型相同，重载对返回类型没有要求

  









### **2.2.14成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？⭐⭐⭐⭐**

**成员初始化列表**：成员初始化列表的位置位于构造函数的函数体和参数表之间，用于初始化数据成员。

对于**const成员和引用成员**必须使用初始化列表进行初始化。



对于普通数据类型，复合类型等，在成员初始化列表和构造函数体中进行，性能和结果是一样的。

对于**用户定义类型**，使用列表初始化可以减少一次默认构造函数调用过程.

1）如果使用类初始化列表，直接调用对应的构造函数即完成初始化

2）如果在构造函数中初始化，**那么首先调用默认的构造函数，然后调用指定的构造函数****，要调用2次，所以不推荐在构造函数内初始化**

```c++
#include<iostream>
Using namespace std;
Class A
{
Public:
    A()
    {
        cout<<"A()"<<endl;
    }
    A(int a)
    {
        value = a;
        cout<<"A(int"<<value<<")"<<endl;
    }
    A(const A& a)
    {
        value = a.value;
        cout<<"A(const A& a):"<<value<<endl;
    }
    int value;
};

class B
{
public:
    B():a(1)
    {
        b = A(2);
    }
    A a;
    A b;
};

int main()
{
    B b;
    system("pause");
}
```

![img](https://uploadfiles.nowcoder.com/images/20200528/545613072_1590659412337_359DB29B4FAC07BEC83578DCBA550942)





### **2.2.15如何避免编译器进行的隐式类型转换；（explicit）⭐⭐⭐⭐**

explicit关键字的作用就是防止类构造函数的隐式自动转换

explicit关键字只对有一个参数的类构造函数有效，或者多参数中除了第一个参数之外的其他参数都是默认值时有效。









# 第三章 网络编程





## 3.1 TCP UDP



### 3.1.1 TCP UDP的区别**⭐⭐⭐⭐⭐**

TCP -- 传输控制协议，提供的时面向连接，可靠的字节流服务，TCP采用数据流的形式传输

UDP -- 用户数据报协议，提供的不可靠的，无连接的服务，UDP采用报文的形式传输。

- TCP是面向连接的，UDP是面向无连接的
- UDP程序结构简单，将收到的报文直接传递给上层应用
- TCP是面向字节流的，UDP是基于数据报的
- TCP保证数据正确性，UDP可能丢包
- TCP保证数据顺序，UDP不保证



### **3.1.2 TCP、UDP的优缺点⭐⭐⭐**

**TCP的优点：可靠稳定**

TCP需要通过三次握手来建立连接，数据传输时有确认，窗口，重传，拥塞控制机制，数据完成后通过四次挥手来断开

**TCP的缺点：慢，效率低，占用系统资源高，易被攻击**

三次握手消耗时间，确认，窗口，重传，拥塞机制也需要消耗时间。

每个建立的连接都会占用系统资源。

因为TCP有确认机制.三次握手机制，这些也导致TCP容易被利用，实现DOS. DDOS. CC等攻击。



**UDP优点：快，比TCP稍安全**

UDP没有TCP拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快。没有TCP机制，不易被攻击

**UDP缺点：不可靠，不稳定**

UDP在传输数据时，易丢包，易乱序





### **3.1.3 TCP UDP适用场景⭐⭐⭐**

TCP：当对网络质量有要求时，比如HTTP，HTTPS，FTP等传输文件的协议；POP，SMTP等邮件传输的协议

UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景





### **3.1.4 TCP为什么是可靠连接⭐⭐⭐⭐**

因为TCP传输的数据满足不丢失，不重复，按顺序到达

TCP保证数据传输可靠性的的方式有

- 连接机制
- 确认应答
- 超时重传
- 缓冲机制
- 流量控制
- 差错控制
- 拥塞控制





### **3.1.5典型网络模型，简单说说有哪些；⭐⭐⭐**

应用层，传输层，网络层，链路层，物理层

![tcpip002](https://s2.loli.net/2022/06/28/n8ZqhiENt1vPWl5.png)





### **3.1.6 Http1.1和Http1.0的区别⭐⭐⭐**

在http1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接，显然这种不断建立连接的方式，会造成很多问题。

  在http1.1中，引入了持续连接的概念，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息，也就是说客户端可以连续发送多个请求，而不用等待每一个响应的到来。







### **3.1.7 URI（统一资源标识符）和URL（统一资源定位符）之间的区别⭐⭐**

URL（统一资源定位符）主要用于链接网页，网页组件或网页上的程序，借助访问方法（http，ftp，mailto等协议）来检索位置资源。

URI（统一资源标识符）用于定义项目的标识，此处单词标识符表示无论使用的方法是什么（URL或URN），都要将一个资源与其他资源区分开来。

URL是一种具体的

URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。









## 3.2 三次握手、四次挥手

![image.png](https://s2.loli.net/2022/06/29/HLUa19XjKsSMCVQ.png)

### **3.2.1什么是三次握手⭐⭐⭐⭐⭐**

1. 客户端向服务端发送请求握手报文，SYN标志位置1，序号段设置为A，确认序号ACK标志位置0,。

2. 服务端收到握手请求报文后，从SYN标志位获取信息，得知客户端请求链接，为TCP连接分配缓存和变量，向客户端发送握手应答报文，SYN标志位置1，序号段设置为B，确认序号ACK标志位置1，确认序号段设置为A+1。

3. 客户端收到握手应答报文，客户端为TCP分配缓存和链接，返回应答报文，SYN标志位置0，序号段设置为A+1,确认序号ACK标志位置1，确认序号段设置B+1;.

   ![tcpip005](https://s2.loli.net/2022/06/28/8TKYbrthgfSw2O9.png)









### **3.2.2为什么三次握手中客户端还要发送一次确认呢？可以二次握手吗？⭐⭐⭐⭐**

目的：防止已经失效的握手请求报文突然传送到B，因而产生错误。

若采用两次握手。如A发出握手求情报文，由于未收到应答，再次发送握手请求报文，此时服务端B收到，并且建立链接，数据传输完毕后，释放连接。由于客户端A发出了两次握手请求报文，第一个丢失，第二个建立了连接。然而丢失仅是由于某些网络结点滞留了，延误到某个时间点到达了服务端B，此时服务端误认为客户端A再次发送了握手请求报文，于是服务端发出应答，再次建立了连接，然而客户端A并不知道建立了连接，于是服务端一直等待客户端A，发送数据，则浪费资源。







### **3.2.3为什么服务端易受到SYN攻击？⭐⭐⭐⭐**

服务端分配资源是在第二次握手时分配的，客户端分配资源是在第三次握手时份额啤的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是客户端短时间内伪造大量不存在的IP地址，向服务端发送大量SYN报，服务端收到确认后，分配系统资源并应答，等待客户端应答，而客户端源地址不存在，客户端需要不断地重发，因此导致大量的SYN包占用服务端资源，导致正常的SYN因为队列满而被丢弃，从而导致网络拥塞甚至系统瘫痪。

防范SYN攻击的措施：降低服务器的的等待时间使服务器尽快释放半连接的占用短时，短时间内收到某IP地址的重复SYN则丢弃后续请求。





### **3.2.4什么是四次挥手⭐⭐⭐⭐⭐**

1. 客户端发送连接释放报文，并且停止发送数据。FIN标志位置1，序号段设置为A
2. 服务器端收到连接释放报文，发出终止连接应答，FIN标志位置0，ACK标志位置1，确认序号段为A+1，此时断开客户端至服务期端方向的连接
3. 服务器端想客户端发送连接释放报文，FIN标志位置1，序号段设置为D，ACK标志位置1,
4. 客户端收到连接释放报文，返回终止连接应答，FIN标志位置0，确认序号段设置为D+1，此时断开服务器端至客户端放向的连接

![tcpip006](https://s2.loli.net/2022/06/28/u9fvUNF1bahZHJk.png)









### **3.2.5为什么客户端最后还要等待2MSL？⭐⭐⭐⭐**

保证客户端发送的最后一个ACK报文能够到达服务器端。若服务器端没有收到最后客户端的ACK报文端，服务器端 会重新发送连接释放报文，客户端便可以在2MSL时间能收到服务端重传的报文段，接着再次发出ACK回应报文，并且会重启2MSL







### **3.2.6为什么建立连接是三次握手，关闭连接确是四次挥手呢？⭐⭐⭐⭐**

建立连接时，客户端发出请求握手报文，服务端发送握手应答报文（SYN和ACK标志位同时置1），客户端收到应答后，返回应答报文。

关闭连接时，客户端发送FIN报文，服务端收到后，返回ACK报文，进表示断开客户端至服务端方向的连接。服务端还可以向客户端发送数据，当服务端结束数据传输后，服务器端向客户端发送FIN报文，客户端应答ACK报文，从而关闭服务器端至客户端的连接。













## 3.3 HTTP



超文本传输协议

一种无状态的，以请求/应答方式运行的协议，它使用可扩展的语义和字描述信息格式，与基于网络的超文本信息系统灵活的弧度

![img](https://s2.loli.net/2022/07/21/USyxJpj73TzwunA.png)

### HTTP请求报文

- **请求首行**：包含请求方法，要访问的资源以及所选用的HTTP版本
- **请求头部**：说明服务器要使用的附加信息
- **空行**：请求报文头部后的空行是必须的
- **请求体**：get往往不存在请求体，post请求体包含请求的参数

![在这里插入图片描述](https://s2.loli.net/2022/07/21/erjyGE1SHt7mDLO.png)

![在这里插入图片描述](https://s2.loli.net/2022/07/21/ZQT3Uv6dAaY9MkN.png)

![在这里插入图片描述](https://s2.loli.net/2022/07/21/zjTrueIDOmU9cRw.png)

![在这里插入图片描述](https://s2.loli.net/2022/07/21/vG4JleEQdsyA36c.png)

**①请求方法**，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。不过，当前的大多数浏览器只支持GET和POST。

**②为请求对应的URL地址**，它和报文头的Host属性组成完整的请求URL。

**③是协议名称及版本号。**

**④是HTTP的报文头**，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。

**⑤是报文体**，它将一个页面表单中的组件值通过param1=value1&param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&param2=value2”的方式传递请求参数。



#### GET和POST的区别

- 从参数的传递方面来看，GET请求的参数是直接拼接在地址栏URL的后面，而POST请求的参数是放到请求体里面的。
- 从长度限制方面来看，GET请求有具体的长度限制，一般不超过1024KB，而POST理论上没有,但是浏览器一般都有
- 从安全方面来看，GET请求相较于POST，因为数据都是明文显示在URL上面的，所以安全和私密性不如POST。
- 从本质上来说，GET和POST都是TCP连接，并无实质的区别。但是由于HTTP/浏览器的限定，导致它们在应用过程中体现出了一些不同。GET产生一个数据包，POST产生两个数据包。对于GET请求，浏览器会把http header 和 data 一并发出去，服务器响应200(返回数据)。而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200。



### HTTP响应报文

- **响应首行**（状态行）：协议版本，状态码，成功与失败的状态信息。
- **响应头部**：由一些键值对构成，用来说明客户端要使用的一些附加信息。
- **空行**：响应头部后面的空行是必须的。
- **响应数据**（响应正文）：服务器返回给客户端的数据等信息内容。

![在这里插入图片描述](https://s2.loli.net/2022/07/21/fqlhIvw6tVW3ynm.png)

![在这里插入图片描述](https://s2.loli.net/2022/07/21/h2ufPR7AVkxXCvc.png)

常见状态代码、状态描述、说明：

- 200 OK：客户端请求成功。
- 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。
- 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
- 403 Forbidden：服务器收到请求，但是拒绝提供服务。
- 404 Not Found：请求资源不存在，如：输入了错误的URL。
- 500 Internal Server Error：服务器发生不可预期的错误。
- 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。





### 3.3.1 HTTP1.1和 HTTP2.0的区别？

**新的二进制格式**：HTTP2.0采用二进制格式传输数据，HTTP1.1基于文本格式传输数据

**多路复用**：在一个连接里，允许同时发送多个请求或响应，并且这些请求和响应可以并行传输而不被阻塞，避免出现HTTP1.1的队头阻塞问题

**头部压缩**：HTTP1.1header带有大量信息，而且每次都要重复发送；HTTP2.0把header从数据中分离，封装成头帧和数据帧，利用算法压缩头帧，减少头信息大小

**服务端推送**：HTTP2.0允许服务端向客户端推送资源







### 3.3.2 **HTTPS与HTTP的区别**

- HTTP是超文本传输协议，信息是明文传输；HTTPS是具有安全性的SSL加密传输协议
- HTTPS和HTTP用的端口不同，HTTP端口为80，HTTPS端口为443
- HTTP运行在TCP协议之上;HTTPS运行在SSL协议之上，SSL运行在TCP协议之上
- HTTPS协议需要到CA机构申请证书，需要一定的费用







### 3.3.3 DNS解析过程

![img](https://s2.loli.net/2022/07/23/XCTJbYNVMsElhWH.png)

![img](https://s2.loli.net/2022/07/23/HkPw8yrf9EBhTd1.png)

1. 浏览器搜索自己的DNS缓存
2. 若没有，搜索操作系统的DNS缓存和hosts文件
3. 若没有，则操作系统将域名发送至**本地域名服务器**，本地域名服务器查询DNS缓存，查找成功则返回结果，否则**本地域名服务器**将依次向**根域名服务器，顶级域名服务器，权限域名服务器**发送查询请求，最终返回IP地址给本地域名服务器
4. 本地域名服务器将得到的IP地址返回给操作系统，同时将IP地址缓存
5. 操作系统将IP地址返回给浏览器，同时自己也就将IP地址缓存
6. 浏览器得到域名对应的IP地址







![img](https://s2.loli.net/2022/07/23/9ilgdZWDpkNYJH3.png)



### 3.3.4 浏览器输入URL返回页面过程

![img](https://uploadfiles.nowcoder.com/images/20220709/165763959_1657382179902/5D990C4442877F9FB2FE28BB5C6121AD)

1. 解析URL得到发送给web的信息，并产生HTTP请求信息
2. 查询服务器域名对应的IP地址，这个过程涉及DNS解析
3. 通过DNS获取到IP后，将HTTP的传输工作交给协议栈
4. 经过TCP三次握手建立链接
5. 通过IP模块分装成网络包发送给通信对象
6. 将IP包前加上MAC头部，通过网卡，交换机和路由器传给对端，然后就是反向过程





### 3.3.5 什么是cookie和session？

由于HTTP是无状态协议，需要某种机制来识别具体的用户身份，用来跟踪用户的整个会话。常用的会话跟踪技术是cookie与session

**cookie原理**：就是服务器发给客户端的特殊信息，这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求时都会带上此特殊信息。当用户提供包括用户名在内的个人信息至服务器时，服务器在回传至客户端时一会将这些信息存放在HTTP的响应头中，客户端接收到服务端的响应后，将信息存放在统一位置。客户端再次发送请求时，会携带相应的cookie存放在请求头中再次发回服务器，服务器分析请求头中的cookie得到客户端持有的信息。

![img](https://uploadfiles.nowcoder.com/images/20220709/165763959_1657382021372/7925EEC7DD7518692B45D71491E3027C)

**cookie工作流程**

1. 服务器端创建cookie，保存少量数据将其发送给客户端浏览器
2. 浏览器获得服务器发送的cookie数据，将自动保存到浏览器端
3. 下次访问时，浏览器自动携带cookie数据发送至服务器端



**sessoin原理**：首先浏览器请求服务器访问web时，服务器首先检查客户端请求是否已经包含session标识，称为SESSIONID，如果已经包含SESSIONID说明以前已经为此客户端创建过session，服务器按照sessionid把这个session检索出来使用，如果不包含sessionid，则服务器为此客户端创建session，并生成一个与此session相关联的sessionid存放到cookie中，将此sessionid返回至客户端保存。这样的交互过程，浏览器每次请求时，都会带着此sessionid，服务器端根据此sessionid找到对应的session。以此来达到共享数据的目的。

![img](https://uploadfiles.nowcoder.com/images/20220709/165763959_1657381997069/791356E7DC91BCE169E024E55C6558DD)







### 3.3.6 Cookie和Session的区别？

- 作用范围不同：cookie存放在客户端，session存放在服务端
- 有效期不同：cookie有效期场，如默认登录功能；session有效时间短，客户端关闭或session超时都会失效
- 隐私策略不同：cookie存储在客户端，易被盗窃，session存放在服务器端，相对安全
- 存储大小不同：单个cookie保存数据不超过4K,对于session存储没有上限，但是session不要存放过多数据，需要设置session删除机制





### 3.3.7 什么是对称加密和非对称加密？

**对称加密：**通信双方使用相同的密钥进行加密。特点是加密速度快，缺点是密钥泄露会导致密文数据被破解。常用的对称加密有AES和DES算法

**非对称加密：**生成两个密钥，公钥和私钥。公钥是公开的，任何人可获得，私钥是私人保管的，公钥负责加密，私钥负责解密；或者私钥负责加密，公钥负责解密。此算法安全性更高，但是计算量相对更大，加密和解密更慢，常见的有RSA和DSA



 































# 第四章 常见算法















## 4.2 STL库相关





### STL由什么组成

标准模板库广义上分为容器，算法，迭代器

标准模板库分为六大组件，分别是容器，算法，迭代器，仿函数，适配器，空间配置器

- 容器：各种数据结构，序列式容器，关联式容器等等
- 算法：常用算法，sort，copy等
- 迭代器：扮演了容器与算法的粘合剂
- 仿函数：类似于函数
- 适配器：修饰容器或者仿函数或迭代器接口的东西
- 空间配置器：负责空间的配置与管理











### **4.2.1 vector list异同⭐⭐⭐⭐⭐**

1）数据结构的区别

vector与数组类似，拥有一段连续的内存空间，便于随机访问，时间复杂度为O(1)，内存空间是连续的，在插入和删除时，时间复杂度为O(n)

list底层是双向链表，内存空间不连续。查询效率低，时间复杂度为O(n)，插入和删除效率高，复杂度为O(1)

2)迭代器不同

vector为随机访问迭代器，支持“+” “+=”等操作

list为双向迭代器，支持++







### **4.2.2 vector内存是怎么增长的vector的底层实现⭐⭐⭐⭐**

vector空间的动态增长

​    当添加元素时，若原vector空间大小不足，则会以原有两倍大小另外配置更大空间，将原有空间内容拷贝过来，并释放原空间



![img](https://s2.loli.net/2022/07/22/HpSd2k3rl4eTQGo.png)

  start迭代器指向已用空间的首元素，finish指向已用空间的尾元素的下一个位置，end_of_storage指向可用空间的末尾。

   size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。

   由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n>capacity()时，调用reserve(n)才会改变vector容量。

  resize()成员函数只改变元素的数目，不改变vector的容量。 

**结论：**

  1.空的vector对象，size()和capacity()都为0

  2.当空间大小不足时，新分配的空间大小为原空间大小的2倍。

  3.使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。

  4.当reserve()分配的空间比原空间小时，是不会引起重新分配的。比如此时capacity是20，只reserve（15）是不会重新分配的

5. resize()函数只改变容器的元素数目，未改变容器大小。

















### **4.2.3为什么stl里面有sort函数list里面还要再定义一个sort⭐⭐⭐**

- 对于支持随机访问迭代器的vector,deque使用STL中的sort函数
- 不支持随机访问迭代器的list，不能使用STL中的sort函数，需要在类中定义sort()成员函数
- 对于关系型容器基于红黑树的set，multiset，map，multimap，本身就有自动排序，不需要sort函数
- stack，queue没有迭代器，不能进行排序
- 基于哈希表的unordered_map,不需要进行排序



### 4.2.4 利用迭代器删除元素会发生什么

对于**关联式容器**如（map,set,multimap.multiset），删除当前迭代器，仅会使当前迭代器失效，只要在erase时，递增当前迭代器即可。

```c++
set<int>::iterator iter;
for (iter = valset.begin(); iter != valset.end(); )
{
     if (3 == *iter)
          valset.erase(iter++);
     else
          ++iter;
}
```

对于**序列式容器**（vector，deque，list等），删除当前迭代器，会使后面所有元素的迭代器都失效。因为vector，deque采用连续分配的内存，删除一个元素导致后面的元素都向前移动。但是erase方法会返回下一个有效的iterator

```
vector<int>::iterator iter;

for (iter = val.begin(); iter != val.end(); )
{
     if (3 == *iter)
          iter = val.erase(iter);     //返回下一个有效的迭代器，无需+1
     else
          ++iter;
}
```









### **4.2.5 STL底层数据结构实现⭐⭐⭐⭐**

- vector	底层数据结构为数组，支持快速随机访问
- list          底层数据结构为双向链表，支持快速增删
- deque    底层数据结构为中央控制器和多个缓冲区，支持首尾快速增删，也支持随机访问，也是连续数组
- stack       底层数据结构为list或deque实现，封闭头部
- queue     底层数据结构为list或deque实现，封闭头部
- priority_queue 底层为vector，堆heap为处理规则管理底层容器实现
- set            底层为红黑树，有序，不重复
- multiset   底层为红黑树，有序，可重复
- map          底层为红黑树，有序，不重复
- multimap 底层为红黑树，有序，可重复
- hash_set / hash_multiset / hash_map / hash_multimap 底层为hash表，无序，可重复

**queue stack priority_queue（这三个不是容器，而是适配器，因为是对容器的再封装）没有迭代器，其他都有** 









### **4.2.6 vector和deque的比较⭐⭐⭐⭐**

- deque随机访问效率比vector高
- deque支持头部快速插入删除，效率比vector快很多
- deque需要大量释放操作，vector更快







### **4.2.7 map是如何实现的，查找效率是多少⭐⭐⭐⭐⭐**

红黑树实现，它可以在O(log n)时间内做查找、插入和删除





### **4.2.8几种模板插入的时间复杂度 ⭐⭐⭐⭐⭐**

set和map的插入删除时O(logn)









# 第五章 LINUX内核相关









## 5.1 Linux内核相关







### **5.1.1 Linux内核的组成⭐⭐**

UNIX系统由内核、shell、文件系统和应用程序四部分组成

**LINUX内核**

linux内核是由进程调度，内存管理，虚拟文件系统，设备管理和驱动，网络通信，系统初始化和系统调用等组成

**LINUX shell**

shell是系统的用户界面，提供了用户与内核进行交互操作的接口。将用户输入的命令送入内核执行，是命令解释器。

**LINUX 文件系统**

文件系统时文件存放在磁盘等存储设备上的组织方法。LINUX系统能支持目前流行的文件系统。如EXT2，EXT3，FAT，FAT32

**LINUX 应用程序**

标准的linux系统一般都有一套应用程序的的程序集







### **5.1.2用户空间与内核通信方式有哪些？⭐⭐⭐⭐⭐**

1. 系统调用。用户进程通过系统调用进入内核空间，访问内核空间数据
2. 驱动程序。用户空间进程使用封装后的系统调用接口访问驱动设备节点，和在内核空间运行的驱动程序通信
3. 共享内存mmap，在代码中调用接口，实现内核空间和用户空间的地址映射
4. copy_to_user()，copy_from_user()，在驱动程序中调用接口，实现用户空间与内核空间的数据拷贝操作



**问： IPC（进程间通信）机制中最快的，可以跨进程的是什么？**

**答：共享内存。**



**问：Linux的用户态与内核态的转换方法？**

**解答**：Linux下内核空间与用户空间进行通信的方式主要有syscall（system call）、procfs、ioctl和netlink等。还有copy_to_user  copy_from_user共享内存mmap  驱动 

1）syscall：一般情况下，用户进程是不能访问内核的。它既不能访问内核所在的内存空间，也不能调用内核中的函数。Linux内核中设置了一组用于实现各种系统功能的子程序，用户可以通过调用他们访问linux内核的数据和函数，这些系统调用接口（SCI）称为系统调用；

2）procfs：是一种特殊的伪文件系统 ，是Linux内核信息的抽象文件接口，大量内核中的信息以及可调参数都被作为常规文件映射到一个目录树中，这样我们就可以简单直接的通过echo或cat这样的文件操作命令对系统信息进行查取；应该就是根目录里的/proc

3）netlink：用户态应用使用标准的socket API就可以使用netlink提供的强大功能；

4）ioctl：函数是文件结构中的一个属性分量，就是说如果你的驱动程序提供了对ioctl的支持，用户就可以在用户程序中使用ioctl函数控制设备的I/O通道。





### **5.1.3系统调用read()/write()，内核具体做了哪些事情⭐⭐**

 用户空间read()-->内核空间sys_read()-->scull_fops.read-->scull_read()；

用户空间通过终端方式将控制权交给内核处理，内核接管后，经过6个层次的处理交给磁盘，磁盘完成最终的数据拷贝操作。







### **5.1.4系统调用的作用⭐⭐⭐⭐⭐**

1.  为了管理硬件资源以及为应用程序开发人员提供良好的环境来是应用程序具有更好的兼容性。内核提供了一系列内核函数，通过系统调用接口呈现给用户。
2. 具有多任务处理的功能，通常靠进程来实现
3. 为了安全问题，一些I/O操作的指令被限制在只有内核模式才可以进行，因此操作系统提供接口来为应用程序提供读取磁盘数据的接口。
4. 操作系统接收到系统调用的请求后，让处理器进入内核模式，从而进行I/O操作，等指令，完成系统调用内容后，操作系统会让处理器返回用户模式







### **5.1.5内核态，用户态的区别⭐⭐⭐⭐⭐**

内核态，操作系统在内核运行

用户态，应用程序只能在用户态运行

当一个进程在执行用户代码时处于用户态，此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户程序运行的程序都是在用户态。3级状态不能访问0级的地址空间。当进程因为系统调用进入内核态时，此时特权级最高，为0级。执行内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈



### Bootloader

**Bootloader=Boot + loader**

Boot的目的：
最终目的：跳到C语言中；为了C语言运行程序会进行一系列的初始化，系统一上电后如何通过一系列的设置让软件程序员进入C语言/更高级语言环境的开发，这个过程就是boot的主要目的。

Loader的目的：
主要目的是开始执行应用逻辑，比如点灯：需要灯的接口开发；串口输入输出：需要串口编程；加载linux的内核：flash的编程、网卡的编程、内核启动前的初始化部分。根据不同的应用会有不同的变化。

一个开发板要想执行loader，要先看boot做了什么事。

**完成Boot最终目的的前提条件**

围绕boot的最终目的，对执行最终目的的前提条件进行说明：

前提条件：

（1）让SP指向可读可写的设备空间中

（2）满足递减栈的规则—SP想办法放在内存的高段地址

（3）配置SDRAM的控制器。首选空间为SDRAM，SDRAM不是系统一上电就好，所以在做（1）、（2）之前要配置SDRAM的控制器，使SDRAM可以正常工作。

（4）配置系统工作时钟，通过代码对相应寄存器进行相关配置即可实现。

（5）关闭看门狗、中断、MMU、CACHE，通过汇编语言对相应的寄存器进行置位即可实现。

开发时前提条件的执行顺序：（5）、（4）、（3）、（1）、（2）



### **5.1.6 bootloader 内核 根文件的关系⭐⭐⭐⭐**



启动顺序：bootloader->linuxkernel->rootfile

bootloader为启动引导程序，初始化处理器及外设，调用linux内核

linux内核在完成系统初始化后需要挂载某个文件系统作为根文件系统，然后加载必要的内核模块，启动应用程序

嵌入式Linux系统通过Bootloader引导，一上电，就要执行Bootloader来初始化系统。在完成对系统的初始化任务之后，它会将非易失性存储器（通常是Flash或DOC等）中的Linux内核拷贝到RAM中去，然后跳转到内核的第一条指令处继续执行，从而启动Linux内核。Bootloader和Linux内核有着密不可分的联系。





### **5.1.7 Bootloader多数有两个阶段的启动过程：⭐⭐⭐**

**stage1：汇编**

- 基本硬件初始化（关闭看门狗，中断，MMU，cache)，配置系统工作时钟
- 为加载stage2准备ram空间
- 拷贝内核映像和文件系统映像到RAM中
- 设置堆栈指针sp
- 跳入到STAGE2

**stage2：C语言**

- 初始化本阶段要使用的硬件设备
- 检测系统的内存映射
- 加载内存映像和文件系统映像
- 设置内核启动参数





### **5.1.8 linux的内核是由bootloader装载到内存中的？⭐⭐⭐**







### **5.1.9为什么需要BootLoader⭐⭐⭐⭐**

整个系统的加载启动任务完全由bootloader完成。bootloader是在操作系统内核运行之前运行的一小段程序，通过此程序初始化硬件设备，建立内存空间映射图。从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核准备好正确的环境。





### **5.1.10 Linux内核同步方式总结⭐⭐⭐⭐**

内核抢占：如果进程正在执行内核函数时（即它在内核态运行），允许发生内核切换，这个内核就是抢占的

1. **原子操作**

   原子操作保证执行过程不被打断

2. **自旋锁**

   自旋锁会关闭内核抢占，持有自旋锁的进程会一直占用CPU，不会被其他进程抢占

3. **信号量**

   信号量的睡眠是可以被打断的，LINUX内核提供了可以被打断和不可以被打断的两种方式

4. **互斥体**

   互斥体与计数为1的信号量基本相同

5. **完成变量**

6. **顺序锁**

   顺序锁为依赖于序列计数器的读写锁

7. **禁止内核抢占**

8. **内存屏障**







### **5.1.11为什么自旋锁不能睡眠 而在拥有信号量时就可以？⭐⭐⭐⭐**

自旋锁禁止处理器抢占；信号量不禁止处理器抢占

基于这个原因，如果自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其他系统进程将都不能获得CPU而运行，因此不能唤醒睡眠的自旋锁，因此系统将不响应任何操作（除了中断或多核的情况，下面会讨论）。而信号量在临界区睡眠后，其他进程可以用抢占的方式继续运行，从而可以实现内存拷贝等功能而使得睡眠的信号量程序由于获得了等待的资源而被唤醒，从而恢复了正常的代码运行。





### **5.1.12 linux下检查内存状态的命令⭐⭐⭐**

https://www.cnblogs.com/leaves1024/p/11190390.html

**free命令**

free 命令会显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存等



**vmstat命令**

　vmstat 是Virtual Meomory Statistics（虚拟内存统计）的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控，是对系统的整体情况进行的统计



**top命令**

​	使用top命令，可以查看正在运行的进程和系统负载信息，包括cpu负载、内存使用、各个进程所占系统资源等，top命令以一定频率动态更新这些统计信息。



**cat/proc/meminfo**

/proc/meminfo是了解Linux系统内存使用状况的主要接口，我们最常用的”free”、”vmstat”等命令就是通过它获取数据的。/proc/meminfo所包含的信息比”free”等命令要丰富得多，但也很复杂



**ps -aux**

ps aux 命令可以查看系统中各个进程的运行情况，包括了进程占用的内存，**%MEM** 列就是各个进程的内存占用百分比。









## 5.2 其他操作系统常见面试问题





### **5.2.1大小端的区别以及各自的优点，哪种时候用⭐⭐⭐⭐⭐**

大端模式：数据的高字节保存在内存的低地址中，数据的低字节保存在内存的高地址中

小端模式：数据的高字节保存在内存的高地址中，数据的低字节保存在内存的低地址中

大端优点：符号位在所表示的数据的内容的第一个字节，便于快速判断数据的正负大小

小端优点：低地址放低字节，在强制转换时不需要调整字节的内容。而且CPU做数值运算时从内存中依次从低到高取数据进行运算。

![img](https://uploadfiles.nowcoder.com/images/20200604/545613072_1591240251465_D9859640F5A6B0301729DADDDBA454E0)

1）如果按照大端模式存储：从低地址到高地址：20 15 08 10 

 存放高字节放低地址，输出从低地址到高地址：20 15 08 10 so 结果就是 2015 810  

2）如果按照小端模式存储：从低地址到高地址：10 08 15 20 

  存放高字节放高地址，输出从高地址到低地址：08 10 20 15 so 结果就是 810 2015 



1）Interl x86系列芯片使用小端存储模式，ARM的芯片默认小端，但可以切换到大端；

2）网络上普遍采用大端模式，使用大端的CPU： power pc 、DSP … …

3）大小端是由CPU架构决定的， 不是软件决定！！





### **5.2.2 一个程序从开始运行到结束的完整过程（四个过程）⭐⭐⭐⭐⭐**

预处理--编译--汇编--链接

**预处理**

预处理过程中，处理源代码中的预处理指令，引入头文件，去除注释，处理所有的条件编译指令，宏的替换，添加行号，保留所有编译指令。

**编译**

编译过程是对预处理后的文件进行语法分析，词法分析，语义分析，符号汇总，然后生成汇编代码

**汇编**

汇编过程将汇编代码转成二进制文件

**链接**

将有关的目标文件彼此相连接







### **5.2.3什么是堆，栈，内存泄漏和内存溢出？⭐⭐⭐⭐**

**内存泄露**

向系统申请分配内存，使用完后未对内存进行释放，就会导致内存泄漏

**内存溢出**

要求分配的内存超出系统分配的，系统不能满足需求，于是产生溢出

**内存越界**

使用向系统申请的内存时，超出申请的内存范围









### **5.2.4堆和栈的区别⭐⭐⭐⭐⭐**

![img](https://uploadfiles.nowcoder.com/images/20200604/545613072_1591240396551_CFD7B443AE1229B43D9ED1E7B10FA85E)







### **5.2.5死锁的原因、条件 创建一个死锁，以及如何预防⭐⭐⭐⭐⭐**

死锁的必要条件

- 互斥条件：一个资源每次只能被一个进程所使用
- 不可剥夺条件：进程对已获得的资源，在未使用完之前，不可以被其他进程剥夺
- 请求与保持条件：一个进程因请求其他资源而阻塞，而此时它持有其他资源
- 循环等待条件：思索必然存在循环等待链



**破坏互斥条件**

利用spooling技术将独占设备改造为共享设备

**破坏不可剥夺条件**

当某个进程请求新的资源得不到满足时，立即释放保持的所有资源。

**请求与保持条件**

在程序运行前，进程申请完它所有需要的全部资源，在资源未满足前，不可投入运行

**循环等待条件**

采用顺序资源分配法。首先给系统资源编号，规定每个进程必须按编号递增的顺序申请资源。只有占据小编号资源时，才有资格申请更大编号的资源。





### **5.2.6 硬链接与软链接的区别；⭐⭐⭐⭐⭐**

硬链接：基于索引结点的共享方式

硬链接引用的是文件在文件系统中的物理索引，当需要移动或删除文件时，硬链接不会被破坏



软链接：基于符号链的共享方式

软链接是创建一个link文件，记录共享文件的存放路径，及时软连接指向的共享文件被删除，link文件依然存在，只是会查找失败

**总结：**

（1）软连接可以跨文件系统，硬连接不可以

（2）硬连接不管有多少个，都指向的是同一个I节点，会把结点连接数增加，只有符号链接才产生新的inode节点，只要结点的连接数不是0，文件就一直存在不管你删除的是源文件还是连接的文件。只要有一个存在文件就存在。 当你修改源文件或者连接文件任何一个的时候，其他的文件都会做同步的修改。软链接不直接使用i节点号作为文件指针, **而是使用文件路径名作为指针**。所以删除连接文件对源文件无影响，但是删除源文件，连接文件就会找不到要指向的文件。软链接有自己的inode, 并在磁盘上有一小片空间存放路径名。

（3）软连接可以对一个不存在的文件名或者目录进行连接。





### **5.2.7虚拟内存，虚拟地址与物理地址的转换⭐⭐⭐⭐**

**虚拟内存**，就是基于局部性原理，将程序很快用到的部分装入内存，暂时用不到的留在外存。程序执行过程中，访问信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后执行程序。

**虚拟地址与物理地址的转换**

首先通过访问的逻辑地址判断页号和页内偏移量，通过页表寻找其对应的内存块号，通过内存块号加页内偏移量从而得到物理地址







### **5.2.8计算机中，32bit与64bit有什么区别⭐⭐⭐**

**处理数据能力**

32位计算机CPU一次可以处理32位数据，64位计算机CPU一次可以处理64位数据，

**寻址能力不同**

32位最多支持4G内存，64位可支持百G内存







### **5.2.9中断和异常的区别⭐⭐⭐⭐⭐**

中断--外中断--是指由于外部设备或人为因素引起的中断

异常--内中断--由于CPU内部事件引起的中断

中断：I/O中断，时钟中断，硬件故障

异常：系统调用，缺页故障，断点指令，保护性异常





### **5.2.10中断怎么发生，中断处理大概流程⭐⭐⭐⭐**

1. 每条指令执行结束后, CPU检查是否有外部中断信号

2. 若有外部中断信号,则需要保护被中断进程的CPU环境

3. 根据中断信号类型转入相应的中断处理程序（核心态）

4. 恢复原进程的CPU环境并退出中断,返回原进程继续往下执行

![img](https://s2.loli.net/2022/07/25/eRFO8BX5bTij7yf.png)

请求中断-响应中断-关闭中断-保留断点-中断源识别-保护现场-中断服务子程序-恢复现场-中断返回

**请求中断：**当某一中断源需要CPU为其进行中断服务时，就输出中断请求信号，使中断控制系统的中断请求触发器置位，向CPU请求中断。系统要求中断请求信号一直保持到CPU对其进行中断响应为止；

**中断响应：**CPU对系统内部中断源提出的中断请求必须响应，而且自动取得中断服务子程序的入口地址，执行中断服务子程序。对于外部中断，CPU在执行当前指令的最后一个时钟周期去查询INTR引脚，若查询到中断请求信号有效，同时在系统开中断（即IF=1）的情况下，CPU向发出中断请求的外设回送一个低电平有效的中断应答信号，作为对中断请求INTR的应答，系统自动进入中断响应周期；

**保护现场：**主程序和中断服务子程序都要使用CPU内部寄存器等资源，为使中断处理程序不破坏主程序中寄存器的内容，应先将断点处各寄存器的内容（主要是当前IP（将要执行的下一条地址）和CS值（代码段地址））压入堆栈保护起来，再进入的中断处理。现场保护是由用户使用PUSH指令来实现的；

**中断服务：**中断服务是执行中断的主体部分，不同的中断请求，有各自不同的中断服务内容，需要根据中断源所要完成的功能，事先编写相应的中断服务子程序存入内存，等待中断请求响应后调用执行；

**恢复现场：**当中断处理完毕后，用户通过POP指令将保存在堆栈中的各个寄存器的内容弹出，即恢复主程序断点处寄存器的原值。

**中断返回：**在中断服务子程序的最后要安排一条中断返回指令IRET（interrupt return），执行该指令，系统自动将堆栈内保存的IP（将要执行的下一条地址）和CS值（代码段地址）弹出，从而恢复主程序断点处的地址值，同时还自动恢复标志寄存器FR或EFR的内容，使CPU转到被中断的程序中继续执行。







### **5.2.11** **Linux 操作系统挂起、休眠、关机相关命令⭐⭐**

**挂起**：是一种省电模式，系统将机器的硬盘，显示器等外部设备停止工作，而CPU，内存仍然工作，等待用户随时唤醒

**休眠**：一种更加省电的模式，它将内存中的数据保存于硬盘中，使CPU也停止工作，当再次使用时需按开关机键，机器将会恢复到您的执行休眠时的状态，而不用再次执行启动操作系统复杂的过程。

**待机**是将当前处于运行状态的数据保存在内存中，机器只对内存供电，而硬盘、屏幕和CPU等部件则停止供电。由于数据存储在速度快的内存中，因此进入等待状态和唤醒的速度比较快。不过这些数据是保存在内存中，如果断电则会使数据丢





**5.2.12数据库为什么要建立索引，以及索引的缺点⭐⭐**









# 第六章 ARM相关知识





### **6.1 CPU  内存 虚拟内存 磁盘/硬盘 的关系**

![img](https://s2.loli.net/2022/07/25/1xuI2AieYzFXZLf.png)

CPU从内存或缓存中取出指令，放入指令寄存器中，并对指令译码分解成一系列微操作，从而完成系统指令的执行。

CPU无法直接读取存储在硬盘中的系统，程序和数据，都是先将数据交换至内存，才能被CPU读取运行。









**6.2 CPU内部结构**

**6.3 ARM结构处理器简析**

**6.4波特率是什么，为什么双方波特率要相同，高低波特率有什么区别；**

