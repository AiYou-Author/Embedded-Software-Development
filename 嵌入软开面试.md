# 第一章进程线程



## 1.1 进程线程的基本概念



### 1.1.1 什么是进程，线程，彼此有什么区别



**PCB，程序段，数据段**三部分构成了进程实体

进程就是进程实体的运行过程，是系统进行**资源分配**和**调度**的一个独立单位



线程为**程序执行流的最小单位**

线程为CPU分配时间资源的基本单元



**区别**：

一个进程可以拥有多个线程。同一进程的不同线程间共享进程的资源。

通信：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间直接使用进程数据段进行通信

调度和切换：同一进程间切换系统开销很小



### 1.1.2 多进程、多线程的优缺点



多进程

优点：多进程使用独立的地址以及资源，一个进程结束不会影响其他进程

缺点：多进程进行任务切换，会大量浪费CPU资源



多线程

优点：任务切换效率高；所有线程共享内存和变量；多线程间通信较为容易

缺点：一个线程崩溃影响整个进程；线程之间的同步和加锁控制比较麻烦；

|          | 多进程                                         | 多线程                                                       |
| :------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 资源     | 多进程使用独立的地址以及资源，进程之间互不影响 | 多线程共用地址以及资源，同一进程中的一个线程死了会影响其他线程 |
| 性能     | 多进程更强，享有独立资源                       | 多线程共用资源                                               |
| 花销     | 进程切换效率低，耗费大量资源                   | 线程切效率高                                                 |
| 通信     | 进程间通信需跨越进程边界                       | 线程间通信使用共享内存和变量                                 |
| 控制逻辑 | 多进程更为复杂                                 | 多线程控制逻辑更为容易，但是需要线程同步和加锁控制           |
| 数量     | 进程数量由CPU决定                              | 线程数量由进程的空间资源和线程本身栈大小决定                 |



### 1.1.3 什么时候用进程，什么时候用线程

需要频繁快速切换的时候选择线程

需要安全稳定时选择进程







### 1.1.4多进程、多线程同步的方法

进程间通信：

- 管道、无名管道
- 消息队列
- 信号量
- 共享内存
- 信号
- socket

线程间通信：

- 信号量
- 读写锁
- 条件变量
- 互斥锁
- 自旋锁

#### 互斥锁与信号量的区别

互斥锁用于线程互斥，信号量用于线程同步以及进程同步









### 1.1.5 进程的空间模型

![img](https://s2.loli.net/2022/06/23/36YvmCrwjh5SQbi.png)

32位系统，运行程序创建进程时，为其分配4G的虚拟地址空间，3G为用户空间，1G为内核空间

栈：由编译器自动分配和释放，存放函数的参数值，局部变量等

堆：一般由程序员分配和释放，若不释放会造成内存泄漏，程序结束可能又操作系统收回。

全局区：全局变量和静态变量放在一起，分为未初始化（.bss）和初始化（.data）的区域

文字常量区：常量字符串，程序结束后由系统释放（.rodata）

程序代码区：存放函数的二进制代码（.txt）



### 1.1.6 一个进程可以创建多少个线程，和什么有关



一个进程的可用虚拟空间为2G，默认情况下，线程的栈的大小为1MB，理论上可以创建2048个线程。

一个进程可以创建的线程个数由虚拟空间大小以及线程栈的大小决定。







### 1.1.7 进程线程的状态转换图，什么时候阻塞，什么时候就绪？

创建态：进程正在被创建，初识PCB，分配资源

就绪态：进程已具备除CPU外的所有资源

运行态：占用CPU，在处理机上运行

阻塞态：由于等待某些资源而导致进程暂停运行

结束态：撤销进程，撤销PCB，撤销资源

挂起态：由于某些资源得不到，将进程挂入外存

![image-20220530154124719](https://s2.loli.net/2022/06/23/DVRkhzH2lP9ox5I.png)







### 1.1.8 父进程，子进程的关系和区别

子进程继承父进程：

   ○用户号UIDs和用户组号GIDs

   ○环境Environment

   ○堆栈

   ○共享内存

   ○打开文件的描述符

   ○执行时关闭（Close-on-exec）标志

   ○信号（Signal）控制设定

   ○进程组号

   ○当前工作目录

   ○根目录

   ○文件方式创建屏蔽字

   ○资源限制

   ○控制终端

子进程独有的：

   ○进程号PID

   ○不同的父进程号

   ○自己的文件描述符和目录流的拷贝

   ○子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）

   ○不继承异步输入和输出 



父进程：

子进程：由父进程使用fork()系统调用创建。

**联系：**

创建子进程作为父进程的副本；子进程继承父进程大部分的属性。

子进程与父进程拥有相同内容的代码段、数据段和用户堆栈，目录。

**区别**：

子进程拥有自己的进程号PID，拥有独立的地址空间，自己的文件描述符和目录流的拷贝





### 1.1.9 什么是进程上下文，中断上下文

**进程上下文**：

​	一个进程在执行的时候，CPU中的所有寄存器中的值，进程的状态以及堆栈中的内容，当需要切换到另外一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次运行此进程时，能够恢复切换前的状态。

​	切换到内核态后执行的程序，即运行在内核空间的部分。



**中断上下文：**

​	由硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文可以理解为硬件传递过来的这些参数和内核需要保存的一些环境。

​	当用户进程想要访问系统资源，必须通过系统调用或者中断切换到内核态，由内核执行。









## 1.2 并发、同步、异步、互斥、阻塞、非阻塞的理解





### 1.2.1 并发、同步、异步、互斥、阻塞、非阻塞的概念

**并发**：两个或多个事件在同一时间间隔发生，就是微观上交替发生，宏观上同时发生。

**同步**：两个或多个进程的运行必须按照严格的先后顺序进行

**互斥**：对于某些临界资源的访问，需要互斥的进行，同一时段只允许一个进程访问该资源。

**异步**：异步彼此独立，不需要等待某个事件的发生才能工作

**注意：**

1）线程是实现异步的一个方式。可以在主线程创建一个新线程来做某件事，此时主线程不需等待子线程做完而是可以做其他事情。

2）异步和多线程并不是一个同等关系。异步是最终目的,多线程只是我们实现异步的一种手段。

**阻塞**：指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

**非阻塞**：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。



一般来说可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。

**同步阻塞**：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果就一直等待，等待期间不做任何操作。

**同步非阻塞**：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果，就立即返回，接收方继续做他事情，此时并未响应发送方，发送发就一直等待，直到接收方读取结果响应发送方，接收方才可以进入下一次请求。

**异步阻塞**：发送方发出请求后，不等待响应，继续其他工作（异步），接收方开始读取文件，如果不能马上得到读取结果就一直等待，等待期间不做任何操作。

**异步非阻塞**：发送方发出请求后，不等待响应，继续其他工作（异步），接收方读取文件如果不能马上得到结果，也不等待，而是马上返回取做其他事情。当IO操作（读取文件）完成以后，将完成状态和结果通知接收方，接收方在响应发送方。（效率最高）

**总结：** 

1）同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。

2）阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。

3）阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。



### 1.2.2 什么是线程同步和互斥

线程同步：线程之间的一种制约关系，一个线程依赖另一个线程的消息，每个线程都按照约定的先后次序运行

线程互斥：针对共享的临界资源，同一时段只允许一个线程访问资源，直到占用资源者释放资源后，其他线程才可以访问。





### 1.2.3 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？

**同步是一个过程，阻塞是一种状态。**

**线程同步不一定发生阻塞**，线程同步时，只有两个资源出现相互等待和相互唤醒时才会出现阻塞。











## 1.3 孤儿进程、僵尸进程、守护进程的概念







### 1.3.1 基本概念

**孤儿进程**：当父进程退出时，子进程仍然在运行，则子进程就是孤儿进程。

**僵尸进程**：子进程退出后，父进程没有调用wait()函数接收结束子进程，子进程停留在系统中，这就是僵尸进程。

**守护进程**：守护进程不受终端影响，退出终端也可以运行。



### 1.3.2 如何创建守护进程

1）**创建子进程，退出父进程**。利用`fork()`函数。

2）**创建新会话，摆脱终端影响**。利用`setsid()`函数创建新会话，并担任该会话组的组长，摆脱原会话的控制==>摆脱原进程的控制==>摆脱原控制台的控制。

3）**改变守护进程的工作目录为根目录**。利用`chrdir()`函数改变目录。

4）**重设文件权限掩码**。子进程继承了父进程的权限掩码，通过`umask()`函数屏蔽掉文件权限中的对应位，需要将子进程置零，拥有较大权限，提高守护进程灵活度。

5）**关闭不需要的文件描述符**。从父进程继承的文件描述符，不需要的可以关闭。

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>

int main()
{
        pid_t pid;
        int fd,len,i,num;
        char *buf="the dameon is running\n";
        len =strlen(buf)+1;


        pid=fork();
        if(pid>0)
        {
                exit(0);
        }

        //创建新会话，摆脱终端影响
        setsid();

        //改变当前工作目录
        chdir("/");

        //重设文件权限掩码
        umask(0);
    
		//关闭不需要的文件描述符
        for(int i=0;i<3;i++)
        {
                close(i);
        }

        while(1)
        {
                fd=open("/var/log/dameon.log",O_CREAT|O_WRONLY|O_APPEND,0666);
                write(fd,buf,len);
                close(fd);
                sleep(5);
        }
        return 0;
}
```









### 1.3.2 正确处理孤儿进程、僵尸进程的方法

**孤儿进程的处理：**

​	孤儿进程会有linux系统中的1号进程init进程来处理，他利用wait()函数来处理已经退出的子程序

**僵尸进程的处理：**

​	如果父进程一直不调用wait/waitpid函数接收子进程，那么子进程就一直保存在系统里，占用系统资源，因此如果僵尸进程数量太多，那么就会导致系统空间爆满，无法创建新的进程，严重系统工作

​	系统规定，子进程退出后，父进程会自动收到SIGCHLD信号。因此我们需要在父进程里重置signal函数。每当子进程退出，父进程都会收到SIGCHLD信号，故通过signal函数，重置信号响应函数。

```c
void* handler(int sig)
{
    int status;
    if(waitpid(-1, &status, WNOHANG) >= 0)
    {
        printf("child is die\n");
    }
}
int main()
{
    signal(SIGCHLD, handler);
    int pid = fork();
    if(pid > 0)  //父进程循环等待
    {
        while(1)
        {
            sleep(2);
        }
    
    }else if(0 == pid){   //子进程说自己die后就结束生命周期，之后父进程就收到SIGCHLD
                          //信号调用handler函数接收结束子进程，打印child is die。
        printf("i am child, i die\n");
    }
}
```





```c
pid_t wait(int *status);
pid_t waitpid(pid_t pid,int *status,int options);
```

`wait()`:

​	成功返回`pid`，失败返回-1；

`status:`

WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）

WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）



`waitpid()`:

​	成功返回`pid`，失败返回-1；

`pid：`

​	pid=-1,等待任意一个子进程，和wait等效

​	pid>0:只等待进程id等于pid的进程

​	pid=0:等待同一进程组的任意一个进程，如果子进程加入其他进程组不加理会

​	pid<-1时，等待一个指定进程组中的任意一个进程，这个进程组的id就是pid的绝对值

`status:`

​	WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）

​	WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）

`options:`

​	WNOHANG:若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回孩子进程的进程id



waitpid有wait没有的三个功能：

（1）waitpid能等待一个特定的子进程，而wait只能等待任意的子进程，

（2）系统一旦调用wait函数就会阻塞父进程来等待，直到等到子进程的退出才停止阻塞，而waitpid提供了一种非阻塞方式的等待，也就是第三个参数，当第三个参数设置为WNOHANG，当子进程没有结束，直接返回0，不等待

（3）waitpid支持作业控制，提供用于检查wait和waitpid返回状态的宏这两个函数返回的子进程的状态都保存在status指针中

WIFEXITED(status): 若为正常终止, 则为真. 此时可执行 WEXITSTATUS(status): 取子进程传送给exit或_exit参数的低8位.

WIFSIGNALED(status): 若为异常终止, 则为真.此时可执行 WTERMSIG(status): 取使子进程终止的信号编号.

WIFSTOPPED(status): 若为当前暂停子进程, 则为真. 此时可执行 WSTOPSIG(status): 取使子进程暂停的信号编号









# 第二章 C/C++







## 2.1 c和c++区别、概念相关面试题



### malloc和free

```c
(int*)malloc(4);
// 申请了一个四个字节的空间并且规定该空间为一个int型变量空间，而不是别的。

int *p =(int*)malloc(4);
// 由于malloc返回一个 空间地址，所以需要一个相应类型的指针来接收改地址

int *p;
p=(int*)malloc(4);
//也可以分写
```

```c
//堆区申请内存
int *p=malloc(sizeof(int)*5);  //申请了5个int类型的空间

//栈区申请内存
int a[5];
int *p=&a[0];

free(p);
```











### **2.1.1 new和malloc的区别**

1. new、delete是C++中独有的操作符，而malloc和free是C/C++中的标准库函数

2. 使用new创建对象在分配内存时会自动调用构造函数，同时完成对象的初始化。delete可以自动调用析构函数。

   malloc和free是库函数不是运算符，不能自动调用构造函数和析构函数。malloc只是单纯地为变量分配内存，free只是释放变量的内存。

3. new返回的是指定类型的指针，并可以自动计算所申请的内存大小。

   malloc返回的是void*类型，需要强行将其转换为实际类型的指针，并指定要申请内存的大小。

4. C++允许重载new/delete，而malloc和free是函数不可以重载

5. new分配内存失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL

6. 自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配。

   new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。







### **2.1.2 malloc的底层实现**

​	Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。我们用malloc进行内存分配就是从break往上进行的。

![img](https://s2.loli.net/2022/06/27/OBo16q5YmIlzETX.png)

malloc函数的实质是将一个可用的内存块链接为一个长长的空闲分区链表。调用malloc()函数时，它沿着链接表寻找一个大到足以满足用户需求的内存块。然后将内存块划分出用户申请的大小，将剩余部分返回到链接表。

free函数，将用户释放的内存空间连接到空闲链表。

​	 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。







### **2.1.3在1G内存的计算机中能否malloc(1.2G)？为什么？**

可以。

malloc函数向操作系统申请一块逻辑地址，与物理地址无直接联系。操作系统利用虚拟内存原理，完成逻辑地址与物理地址的转换。操作系统负责将信息从外存与内存之间调入调出，从而容纳超出内存大小的信息。







### **2.1.4指针与引用的相同和区别；如何相互转换？⭐⭐⭐⭐⭐**

**相同：都是地址的概念**

指针指向一块内存，它的内容是所指变量的地址。引用是某块内存的别名。

从内存来看，两者都占据内存。在32位系统中，指针一般占据4字节内存。引用为指针常量，无法使用sizeof查看其大小

**区别：**

1. 指针是一个实体，引用仅仅是别名；
2. 指针和引用的自增运算意义不同。指针是内存地址的自增，引用是变量值的自增；
3. 指针需要使用解除引用运算符。引用不需要
4. 引用只能在定义时进行初始化。指针可变。
5. 引用不能为空，指针可以为空
6. 引用没有const (int & const a),指针有const(int * const a：此指针不能改变其所指的变量)
7. sizeof 引用 得到是变量的大小；sizeof 指针 得到的是指针本身的大小

**引用和指针之间怎么转换**

1. 指针转引用：指针使用接触引用运算符就可以转换为对象

   ```c++
   void fun(int &val){}
   fun(*pA);
   ```

2. 引用转指针：引用类型的对象使用&取地址符，就可以获得指针

   ```c++
   int a=0;
   int *pA = &a;
   ```

   





### 2.1.5 C语言检索内存情况 内存分配的方式

检索内存：对某段内存进行遍历搜索

内存分配：

1. 静态存储区域分配。内存在程序编译时就已经分配好。如全局变量，常量，静态变量。
2. 栈。函数内局部变量的存储单元可以在栈上创建，函数执行结束时这些存储单元自动释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
3. 堆。动态内存分配。程序员需要自己申请动态内存并且释放内存。动态内存的生存期由程序员决定，若分配了空间未收回，则会出现内存泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。











### 2.1.6  extern”C” 的作用⭐⭐⭐

**extern "C"**是C++特有的指令（C无法使用该指令），目的在于支持C++与C混合编程。

**extern “C”**的作用是告诉**C++编译器**用C规则编译指定的代码（除函数重载外，**extern “C”**不影响C++其他特性）。

**因为C和C++的编译规则不一样，主要区别体现在编译期间生成函数符号的规则不一致**

```c++
//func.h c文件
void func(int set);


//main.cpp c++文件
//法一:
extern "C"{
    #include "func.h"
}

//法二:
#include "func.h"
extern "C" void func(int set);
```





### 2.1.7头文件声明时加extern定义时不要加 因为extern可以多次声明，但只有一个定义⭐⭐⭐⭐

对于外部链接的变量，函数。extern修饰符用在变量和函数的声明前，说明此变量函数的定义在别处，且定义只有一个，此处引用声明。

**extern在链接阶段起作用。**







### 2.1.8函数参数压栈顺序，即关于`__stdcall`和`__cdecl`调用方式的理解⭐⭐⭐

`__stdcall`和`__cdecl`都是函数调用约定关键字，我们先来看看`__stdcall`和`__cdecl`调用方式的概念：

1）`__stdcall`是C++的标准调用方式，参数由右向左压入栈，函数在返回时会自动清除堆栈中的参数

2）`__cdecl`是C语言默认的函数调用方式，参数由右向左压入栈，函数在返回时不会自动清除堆栈中的参数，清除工作由调用者完成。

```c++
int __stdcall Func_stdcall(int nParam1, int nParam2)  
{  
    return 1;  
}  
int __cdecl Func_cdecl(int nParam1, int nParam2)  
{  
    return 1;  
}  
```









### 2.1.9重写memcpy()函数需要注意哪些问题⭐⭐

从存储区 str2 复制 n 个字节到存储区 str1。

```
 void *memcpy(void *str1, const void *str2, size_t n) 
```

- **str1** -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。
- **str2** -- 指向要复制的数据源，类型强制转换为 void* 指针。
- **n** -- 要被复制的字节数。



情况一：两个数组不会重叠，从前至后赋值。

情况二：源地址数组在目标地址前，且两数组重叠，从后至前赋值。

情况三：源地址数组在目标地址后，且两数组重叠，从前至后赋值。

```c
 void *memcpy(void *str1, const void *str2, size_t n) 
 {
     char* pstr1;
     char* pstr2;
     if(str1==NULL||str2==NULL)
     {
         return NULL;
     }
     
     if(str2<str1 && ((char*)str2+n> (char*)str1))
     {
         pstr1=(char*)str1+n-1;
         pstr2=(char*)str2+n-1;
         while(n--)
         {
             *pstr1--=*pstr2--;
         }
     }else
     {
         pstr1=(char*)str1;
         pstr2=(char*)str2;
         while(n--)
         {
             *pstr1++=*pstr2++;
         }
     }
     return str1;
 }
```





### 2.1.10数组到底存放在哪里⭐⭐⭐

1. 定义在全局下的全局变量，就是在数据段里
2. 定义在函数下的局部变量，数组存放在函数调用栈里
3. 程序员使用new申请的动态内存，就是存放在自由存储区里
4. 固定数组在类中分配是在堆中







### 2.1.11  struct和class的区别 ⭐⭐⭐⭐⭐

区别：struct的默认访问控制为public；class的默认访问控制为private









### **2.1.12 char和int之间的转换；⭐⭐⭐**

从四字节的int转换为带符号位的char，取int的最低的一个字节，将其赋给char型数据，且第一位为符号位。

从四字节的int转换为unsigned char，取int的最低的一个字节，将其赋给char型数据，第一位无符号位，则整个字节都是数据。

从char转换为int：将前面三个字节补齐，char首位为1，补上0xfff，char首位为0，补上0x000

从unsigned char转换为int：前三个字节补上0x000





### **2.1.13  static的用法（定义和用途）⭐⭐⭐⭐⭐**

static作用：改变生命周期和改变作用域

static局部变量：**将局部变量由自动存储方式变为静态存储方式**，在程序运行时就为其分配内存，函数执行结束，仍继续保留在内存中。

static全局变量：**改变全局变量的外部链接性为内部链接性，**只在本文件内使用，无法在其他文件中使用。

static函数：**改变函数的外部链接性为内部链接性，**使得函数只在本文件内部有效，对其他文件是不可见的。这样的函数又叫作**静态函数。**

static成员变量：这个成员为全类所共有，类的所有对象都共用一个此成员。

static成员函数：这个函数为全类所共有，**只能访问静态成员变量**





### **2.1.14  cosnt的用法（定义和用途）⭐⭐⭐⭐⭐**

const是常量修饰符，const变量应该在声明的时候就进行初始化，如果在声明变量的时候没有提供值，则该常量值是不确定的，且无法修改。

const修饰主要用来修饰变量，函数形参，函数返回值和类成员函数

1）const变量：定义时就初始化

2）const函数形参：该形参在函数里不能改变

3）const函数返回值：该返回值不能作为左值

4）const类成员函数：在整个函数中不能修改成员变量的值





### **2.1.15 const常量和#define的区别（编译阶段、安全性、内存占用等） ⭐⭐⭐⭐**

**编译阶段**：#define是在编译的**预处理阶**段起作用的；const是在**编译**阶段确定其值的

**作用方式**：#define只是简单的字符替换，没有**类型检查**；const是有**对应的类型的**

**内存占用**：#define所定义的宏变量在内存中有**多个拷贝**；const定义的变量**只有一个拷贝**

**函数作用**：#define可以定义一些函数，const不可以定义函数

**代码调试**：#define在预处理阶段替换，无法调试；const变量可以调试

**作用范围**：#define的作用范围为当前文件；const变量默认的作用范围也是文件内，但是可以使用extern关键字，将其链接性改为外部。

**指针指向**：#define定义常量不能用指针指向；const常量可以用指针指向其地址。



### **2.1.16  volatile作用和用法 ⭐⭐⭐⭐⭐**

​	使用volatile关键字声明的变量或对象通常具有与优化、多线程相关的特殊属性。通常, volatile 关键字用来阻止(伪)编译器认为的无法“被代码本身"改变的代码(变量/对象)进行优化。如在C语言中,volatile关键字可以用来提醒编译器它后面所定义的变量随时有可能改变,因此编译后的程序每次需要存储或读取这个变量的时候,都会直接从变量地址中读取数据。如果没有volatile关键字,则编译器可,能优化读取和存储,可能暂时使用寄存器中的值,如果这个变量由别的程序更新了的话,将出现不致的现象。

总结：

**优点：防止编译器对代码优化，变量值是直接从变量地址中读取和存储的。**

缺点：这种使用过多会导致代码十分庞大。



```c++
int i=0;
int main(void)
{
     ...
     while (1){
        if (i) dosomething();
     }
｝

/* Interrupt service routine. */
void ISR_2(void)
{
      i=1;
}
```

​	程序的本意是希望ISR_2中断产生时，在main函数中调用dosomething函数。但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作，然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。如果**将变量加上volatile修饰，则编译器保证对此变量的读写操作都不会被优化（肯定执行）**。此例中i也应该是**volatile int i**；





### **2.1.17有常量指针 指针常量 常量引用 没有 引用常量⭐⭐⭐**

**常量指针**

```c++
//指针指向的是一个常量，不可以通过指针改变变量的值
const int *p=&a;
int const *p=&a;
```

**指针常量**

```c++
//指针本身的指向不能变
int * const p=&a;
```

**常量引用**

```c++
//不可以通过常量引用r来改变a，可以使用常量引用指向常量
const int &r=a;
const int &r=10;
```





### **2.1.18没有指向引用的指针，因为引用是没有地址的，但是有指针的引用⭐⭐⭐**

指针本质是指向某一块内存空间的，而引用是变量的别名，本身没有地址。所以**没有指向引用的指针**，**如果创建指针指向引用其实是指向引用的对象**。

```c++
int a;
int &r=a;
int *p=&r;//指针p指向的是变量a
```





### **2.1.19c/c++中变量的作用域⭐⭐⭐⭐⭐**

**全局变量：**全局变量是在函数体的外部定义的，程序所在部分都可以使用。全局变量不受作用域影响，其生命周期直到整个程序结束

**局部变量**：局部变量出现在一个作用域内，局限于一个函数。存储在栈中，函数调用结束后，自动释放变量

**寄存器变量**：寄存器变量是一种局部变量，关键字register告诉编译器尽可能快的访问这个变量，访问速度取决于现实。

**静态变量**：关键字static。静态局部变量，可以使变量的生命周期延长至整个程序，但是其作用域不变，函数调用之间这个变量的值不变。静态全局变量，改变了变量的作用域，仅在定义他的文件中使用，不能作用到其他文件里。

**外部变量**：extern关键字告诉编译器，当前变量和函数其定义存在某个文件中，此处只做声明引用

**const常量**：const变量的值是确定值，全局不可以修改，其在定义时必须初始化。

**volatile变量**：限定词volatile则告诉编译器“不知道何时变化”，防止编译器依据变量的稳定性作任何优化。







### **2.1.20** **c++中类型转换机制？各适用什么环境？dynamic_cast转换失败时，会出现什么情况？⭐⭐⭐⭐**

**（1）static_cast**

**static_cast< new_type >(expression)**

静态转换，在编译处理阶段

用于C++内置的基本数据类型转换，将expression转换为new_type,但是不能保证转换的安全性

- ①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。

  进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；

  进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。

- ②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。

- ③把空指针转换成目标类型的空指针。

- ④把任何类型的表达式转换成void类型。

  注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性

```c++
char a = 'a';
int b = static_cast<int>(a);//正确，将char型数据转换成int型数据

double *c = new double;
void *d = static_cast<void*>(c);//正确，将double指针转换成void指针

int e = 10;
const int f = static_cast<const int>(e);//正确，将int型数据转换成const int型数据

const int g = 20;
int *h = static_cast<int*>(&g);//编译错误，static_cast不能转换掉g的const属性
```

```c++
High bar;
Low blow;
High *pb=static_cast<High*>(&blow);
Low *pl=static_cast<Low*>(&bar);
```



**（2）const_cast**

特点：去常转换，编译时执行。不是运行时执行

应用场合：const_cast操作不能在不同的种类间转换。相反，它仅仅把它作用的表达式转换成常量。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。 

const_case只能转换**指针或引用** 不能转换变量

去掉const属性：`const_case<int*> (&num)`，常用，因为**不能把一个const变量直接赋给一个非const变量，必须要转换。**

```c++
//const_cast中的类型必须是引用或者指针
const_cast<type-name>(expression);
const int a = 5;
int r = const_cast<int&>(a);
int *r= const_cast<int*>(a);
```



**（3）reinterpret_cast**

特点： 重解释类型转换

应用场合：它有着和c风格强制类型转换同样的功能；它可以转化任何的内置数据类型为其他的类型，同时它也可以把任何类型的指针转化为其他的类型；它的机理是对二进制进行重新的解释，不会改变原来的格式。



**（4）dynamic_cast <type_id > ( expression )**

dynamic_cast主要用于类层次间的**上行转换**和**下行转换**，还可以用于**类之间的交叉转换**（cross cast）。

上行转换时和static_cast效果一样，下行转换时，具有检测功能，比static_cast更安全。

type_id必须是**类的指针，类的引用或者空类型的指针**，expression必须也是相对应的类型。

如果转换目标是指针类型并且失败了，则结果为0。

如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常

```c++
High* ph;
Low* pl;
pl=dynamic_cast<Low*>ph;//仅当Low是High可访问的基类，才能赋值，否则将空指针付给pl
Hight & ph1=dynamic_cast<low&>(*pl1);
```









## 2.2  继承与多态相关面试题



### **2.2.1继承和虚继承 ⭐⭐⭐⭐⭐**

**继承**：从一个基类派生出一个派生类称为继承

**虚基类**：虚基类是从多个类（他们的基类相同）派生出的对象只继承一个基类对象。

```c++
class Singer:virtual public Worker{};
class Waiter:public virtual Worker{};
class SingingWaiter:public singer,public Waiter{}
//singerWaiter只包含一个worker子对象
```

对于虚基类来说，自动传递将不起作用，需要显示调用虚基类的构造函数

```c++
SingingWaiter(const Worker &wk,int p=0,int v=Singer::other):Waiter(wk,p),Singer(wk,v){}
//C++基类是虚的，禁止信息从中间类传递给基类。
//在上述情况下，编译器将使用worker的默认构造函数
SingingWaiter(const Worker &wk,int p=0,int v=Singer::other):Worker(wk),Waiter(wk,p),Singer(wk,v){}
//显示调用构造函数worker(const Worker&)
```





### **2.2.2多态的类，内存布局是怎么样的 ⭐⭐⭐⭐⭐**

（1）虚继承：如果是虚继承，那么就会为这个类创建一个虚表指针，占用4个字节

```c++
#include <stdio.h>  
class A {  
public:  
    int a;  
}; //sizeof(A)=4，因为a是整形，占用4字节

class B : virtual public A {  
public:  
    int b;  
};//sizeof(B)=4(A副本)+4(虚表指针占用4字节)+4(变量b占用4字节)=12  

class C : virtual public B {       
};//sizeof(c)= 12(B副本)+4(虚表指针) = 16，如果这里改为直接继承，那么sizeof(c)=12，因为此时就没有虚表指针了
```

（2）多重继承：如果是以**虚继承**实现多重继承，记得减掉基类的副本

```c++
#include <stdio.h>  
class A {  
public:  
    int a;  
};//sizeof(A) = 4  

class B : virtual public A {  
};// sizeof(B) =4+4=8  

class C : virtual public A {          
};//sizeof(C) =4+4=8  

class D : public B, public C{         
};  
//sizeof(D)=8+8-4=12这里需要注意要减去4，因为B和C同时继承A，只需要保存一个A的副本就好了，sizeof(D)=4(A的副本)+4(B的虚表)+4(C的虚表)=12，也可以是8（B的副本）+8（c的副本）-4（A的副本）=12
```

（3）普通继承（含有：空类、虚函数）

```c++
class A      //result=1  空类所占空间的大小为1  
{     
};    

class B     //result=8  1+4   字节对齐后为 8  
{  
    char ch;     
    virtual void func0()  {  }   
};   

class C    //result=8  1+1+4 字节对齐后为 8，没有继承的，此时类里即使出现多个虚函数，也只有一个虚指针
{  
    char ch1;  
    char ch2;  
    virtual void func()  {  }    //也只有一个虚指针
    virtual void func1() {  }    //也只有一个虚指针
};  
  
class D: public A, public C  //result=12  8（C的副本）+4（整形变量d占用4字节）=12  
{     
    int d;     
    virtual void func()  {  }   //继承了C，C里已经有一个虚指针，此时D自己有虚函数，
    virtual void func1()  {  } //也不会创建另一个虚指针，所以D本身就变量d需要4字节
};     
  
class E: public B, public C  //result=20   8（ B的副本）+8（C的副本）+4（E本身）=20
{     
    int e;     
    virtual void func0()  {  }   //同理，E不会创建另一个虚指针，所以E本身就变量e需
    virtual void func1()  {  }  //要4字节
};  
```

 （4）虚继承（多重继承和虚函数）

```c++
class CommonBase  
{  
    int co;  
};// size = 4  
  
class Base1: virtual public CommonBase            
{  
public:  
    virtual void print1() {  }  
    virtual void print2() {  }  
private:  
    int b1;  
};//4（父类副本）+4（自己有虚函数，加1个虚指针空间）+4（自身变量b1）+4(虚继承再加1个虚指针空间)=16  

class Base2: virtual public CommonBase          
{  
public:  
    virtual void dump1() {  }  
    virtual void dump2() {  }  
private:  
    int b2;  
};//同理16  
  
class Derived: public Base1, public Base2       
{  
public:  
    void print2() {  }  
    void dump2() {  }  
private:  
    int d;  
};//16+16-4+4=32  
```

如果此时类里有一个或多个虚函数，那么需要加1个虚指针空间，如果还是虚继承，那么需要再加1个虚指针空间，最多就2个虚指针空间。

（5）虚继承与虚函数

```c++
class A  
{  
public:  
    virtual void aa() {  }  
    virtual void aa2() {  } //如果此时类里有一个或多个虚函数，那么需要加1个虚指针空间
private:  
    char ch[3];  
}; // 1+4 =补齐= 8   
  
class B: virtual public A //如果还是虚继承，那么需要再加1个虚指针空间，最多就2个虚指//针空间。
{  
public:  
    virtual void bb() {  }  
    virtual void bb2() {  }  
}; // 8（副本）+4(虚继承)+4（虚指针）= 16  
```





### **2.2.3被隐藏的基类函数如何调用   或者  子类调用父类的同名函数和父类成员变量 ⭐⭐⭐⭐⭐**

1）使用using关键字，调用父类同名函数

```c++
class child:pubilc parent
{
	Child(){};
    using parent::add;
    int add(void){};
}
```

2）使用作用域操作符，调用基类中被隐藏的所有成员函数和变量

```c++
Child a;
a.add();
a.Parent::add();
```





### **2.2.4多态实现的三个条件、实现的原理 ⭐⭐⭐⭐⭐**

**条件：**

1. 继承
2. 虚函数重写
3. 父类指针指向子类对象

**实现原理：**

1、基类中的虚函数

​	类中若定义了虚函数，那么类会多出一个成员指针，称为**虚函数指针**，虚函数指针指向一张虚函数表，**虚函数表中存放的是类中的每一个虚函数地址**，注意非虚函数的成员函数不会放入虚函数表中

2、继承

​	子类继承父类，那么子类会继承除了构造函数和析构函数的所有成员，当然也会继承父类的虚函数指针和虚函数表，可以看做子类的构成中有一个父类

3、重写子类的虚函数 以及子类指针或引用赋值给父类

​	在重写子类的虚函数后，子类的虚函数地址与父类对应的虚函数地址会有不同，**在子类指针或引用赋值给父类时，虚函数表中原先父类的虚函数地址会被重写的子类的虚函数地址覆盖掉**，从而完成不同的子类指针或引用赋值给同一父类指针或引用时，在调用父类的虚函数时回去调用对应子类的虚函数，最终实现多态。

​	注意若在子类定义了父类不具有的虚函数，这个虚函数也会加入子类继承而来的虚函数表中，但是不能通过父类指针或引用去调用这个父类不具有的虚函数，即子类指针或引用赋值给父类后，父类指针或引用的作用范围不能超过父类的成员范围





### **2.2.5对拷贝构造函数 深浅拷贝 的理解 拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？⭐⭐⭐**

**默认拷贝构造函数**，逐个复制非静态成员，对于某些使用new初始化的指针成员，以及字符串成员，仅能复制指向字符串的指针

**深度拷贝**：拷贝函数复制字符串并将副本的地址赋给新成员，而不是仅仅复制字符串地址

**自定义拷贝构造函数**：凡是**包含动态分配成员**或**包含指针的类**都应提供拷贝构造函数





### **2.2.6析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？⭐⭐⭐**

C++标准指明**析构函数不能，也不应该抛出异常。**C++异常处理模型有责任清除那些由于出现异常所导致的失效的对象，并释放对象原来分配的资源。所以析构函数已经变成了异常处理的一部分。

1）如果析构函数抛出异常，则异常之后的程序不会执行，如果异常点后的程序涉及释放资源等，则会造成资源泄露的问题

2）通常异常发生时，会调用析构函数来释放资源，若此时析构函数又抛出异常，则会造成程序的崩溃。







### **2.2.7什么情况下会调用拷贝构造函数（三种情况）⭐⭐⭐**

1. 一个对象以值传递的方式传入函数体
2. 一个对象以值传递的方式从函数返回
3. 对象通过另一个对象进行初始化







### **2.2.8析构函数一般写成虚函数的原因⭐⭐⭐⭐⭐**

在实现多态时，基类指针指向子类对象时，如果析构函数为虚函数，如果删除基类指针，则会调用基类指针指向的子类析构函数，而子类的析构函数又会自动调用基类的析构函数，这样整个子类对象都会被完全释放。

如果不讲析构函数声明为虚函数，则编译器实现静态绑定，删除基类指针时，只会调用基类的析构函数，不会调用子类的析构函数，对子类对象析构不完全。







### **2.2.9构造函数为什么一般不定义为虚函数⭐⭐⭐⭐⭐**

1）**从存储空间来看**：虚函数对应虚函数表的指针，而指向虚函数表的指针事实上是存储在对象的存储空间中。如果构造函数是虚的，就必须通过虚函数表来调用，但是对象没有实例化，内存空间也没有虚函数表，所以构造函数不能是虚函数

2）**使用角度来看**：虚函数的作用在于通过父类的指针或引用调用子类的成员函数。而构造函数在创建对象时自己主动调用，不可能通过父类的指针或引用去调用。

3）**从实现上看**：在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。



### **2.2.10什么是纯虚函数⭐⭐⭐⭐⭐**

纯虚函数：virtual 函数类型 函数名（参数列表）=0；

C++利用纯虚函数提供未实现的函数。纯虚函数不能被调用，其作用是在基类中为派生类保留一个函数的名字，以便派生类对其进行定义。

1. 纯虚函数没有函数体
2. 纯虚函数声明部分最后面有“=0”

凡是含有纯虚函数的类都是抽象类，抽象类是不能实例化的。抽象基类的作用是提供公共接口，派生类只有重新定义后才可以实例化出对象。





### **2.2.11静态绑定和动态绑定的介绍⭐⭐⭐⭐**

静态联编：在编译过程中进行联编

动态联编：编译器必须生成能够在程序运行时选择正确的虚方法的代码

非虚函数使用静态绑定，虚函数使用动态绑定



问题：引用是否能实现动态绑定，为什么引用可以实现 

答：只有指定为虚函数的成员函数才能进行动态绑定，且必须通过基类类型的引用或指针进行函数调用，而指针或引用是在运行期根据他们绑定的具体对象确定。



### **2.2.12 C++所有的构造函数 ⭐⭐⭐**

默认构造函数

拷贝构造函数

构造函数



### **2.2.13重写、重载、覆盖的区别⭐⭐⭐⭐⭐**

重写（覆盖）和重载的区别

- 重写和被重写的函数在子类和父类之间，重载和被重载的函数在一个类中

- 重写和被重写的函数的参数列表相同，重载和被重载的函数的参数列表不相同

- 重写的基类中被重写的函数必须有virtual修饰，重载的函数无要求

- 重写是运行时的多态性，重载是编译时的多态性

- 重写要求返回类型相同，重载对返回类型没有要求

  









### **2.2.14成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？⭐⭐⭐⭐**

**成员初始化列表**：成员初始化列表的位置位于构造函数的函数体和参数表之间，用于初始化数据成员。

对于**const成员和引用成员**必须使用初始化列表进行初始化。



对于普通数据类型，复合类型等，在成员初始化列表和构造函数体中进行，性能和结果是一样的。

对于**用户定义类型**，使用列表初始化可以减少一次默认构造函数调用过程.

1）如果使用类初始化列表，直接调用对应的构造函数即完成初始化

2）如果在构造函数中初始化，**那么首先调用默认的构造函数，然后调用指定的构造函数****，要调用2次，所以不推荐在构造函数内初始化**

```c++
#include<iostream>
Using namespace std;
Class A
{
Public:
    A()
    {
        cout<<"A()"<<endl;
    }
    A(int a)
    {
        value = a;
        cout<<"A(int"<<value<<")"<<endl;
    }
    A(const A& a)
    {
        value = a.value;
        cout<<"A(const A& a):"<<value<<endl;
    }
    int value;
};

class B
{
public:
    B():a(1)
    {
        b = A(2);
    }
    A a;
    A b;
};

int main()
{
    B b;
    system("pause");
}
```

![img](https://uploadfiles.nowcoder.com/images/20200528/545613072_1590659412337_359DB29B4FAC07BEC83578DCBA550942)





### **2.2.15如何避免编译器进行的隐式类型转换；（explicit）⭐⭐⭐⭐**

explicit关键字的作用就是防止类构造函数的隐式自动转换

explicit关键字只对有一个参数的类构造函数有效，或者多参数中除了第一个参数之外的其他参数都是默认值时有效。









# 第三章 网络编程





## 3.1 TCP UDP



### 3.1.1 TCP UDP的区别**⭐⭐⭐⭐⭐**

TCP -- 传输控制协议，提供的时面向连接，可靠的字节流服务，TCP采用数据流的形式传输

UDP -- 用户数据报协议，提供的不可靠的，无连接的服务，UDP采用报文的形式传输。

- TCP是面向连接的，UDP是面向无连接的
- UDP程序结构简单，将收到的报文直接传递给上层应用
- TCP是面向字节流的，UDP是基于数据报的
- TCP保证数据正确性，UDP可能丢包
- TCP保证数据顺序，UDP不保证



### **3.1.2 TCP、UDP的优缺点⭐⭐⭐**

**TCP的优点：可靠稳定**

TCP需要通过三次握手来建立连接，数据传输时有确认，窗口，重传，拥塞控制机制，数据完成后通过四次挥手来断开

**TCP的缺点：慢，效率低，占用系统资源高，易被攻击**

三次握手消耗时间，确认，窗口，重传，拥塞机制也需要消耗时间。

每个建立的连接都会占用系统资源。

因为TCP有确认机制.三次握手机制，这些也导致TCP容易被利用，实现DOS. DDOS. CC等攻击。



**UDP优点：快，比TCP稍安全**

UDP没有TCP拥有的各种机制，是一种无状态的传输协议，所以传输数据非常快。没有TCP机制，不易被攻击

**UDP缺点：不可靠，不稳定**

UDP在传输数据时，易丢包，易乱序





### **3.1.3 TCP UDP适用场景⭐⭐⭐**

TCP：当对网络质量有要求时，比如HTTP，HTTPS，FTP等传输文件的协议；POP，SMTP等邮件传输的协议

UDP：对网络通讯质量要求不高时，要求网络通讯速度要快的场景





### **3.1.4 TCP为什么是可靠连接⭐⭐⭐⭐**

因为TCP传输的数据满足不丢失，不重复，按顺序到达

TCP保证数据传输可靠性的的方式有

- 连接机制
- 确认应答
- 超时重传
- 缓冲机制
- 流量控制
- 差错控制
- 拥塞控制





### **3.1.5典型网络模型，简单说说有哪些；⭐⭐⭐**

应用层，传输层，网络层，链路层，物理层

![tcpip002](https://s2.loli.net/2022/06/28/n8ZqhiENt1vPWl5.png)





### **3.1.6 Http1.1和Http1.0的区别⭐⭐⭐**

在http1.0中，当建立连接后，客户端发送一个请求，服务器端返回一个信息后就关闭连接，当浏览器下次请求的时候又要建立连接，显然这种不断建立连接的方式，会造成很多问题。

  在http1.1中，引入了持续连接的概念，通过这种连接，浏览器可以建立一个连接之后，发送请求并得到返回信息，然后继续发送请求再次等到返回信息，也就是说客户端可以连续发送多个请求，而不用等待每一个响应的到来。







### **3.1.7 URI（统一资源标识符）和URL（统一资源定位符）之间的区别⭐⭐**

URL（统一资源定位符）主要用于链接网页，网页组件或网页上的程序，借助访问方法（http，ftp，mailto等协议）来检索位置资源。

URI（统一资源标识符）用于定义项目的标识，此处单词标识符表示无论使用的方法是什么（URL或URN），都要将一个资源与其他资源区分开来。

URL是一种具体的

URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。



