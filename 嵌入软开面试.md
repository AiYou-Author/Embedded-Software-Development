# 第一章进程线程



## 1.1 进程线程的基本概念



### 1.1.1 什么是进程，线程，彼此有什么区别



**PCB，程序段，数据段**三部分构成了进程实体

进程就是进程实体的运行过程，是系统进行**资源分配**和**调度**的一个独立单位



线程为**程序执行流的最小单位**

线程为CPU分配时间资源的基本单元



**区别**：

一个进程可以拥有多个线程。同一进程的不同线程间共享进程的资源。

通信：进程间通信IPC（管道，信号量，共享内存，消息队列），线程间直接使用进程数据段进行通信

调度和切换：同一进程间切换系统开销很小



### 1.1.2 多进程、多线程的优缺点



多进程

优点：多进程使用独立的地址以及资源，一个进程结束不会影响其他进程

缺点：多进程进行任务切换，会大量浪费CPU资源



多线程

优点：任务切换效率高；所有线程共享内存和变量；多线程间通信较为容易

缺点：一个线程崩溃影响整个进程；线程之间的同步和加锁控制比较麻烦；

|          | 多进程                                         | 多线程                                                       |
| :------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 资源     | 多进程使用独立的地址以及资源，进程之间互不影响 | 多线程共用地址以及资源，同一进程中的一个线程死了会影响其他线程 |
| 性能     | 多进程更强，享有独立资源                       | 多线程共用资源                                               |
| 花销     | 进程切换效率低，耗费大量资源                   | 线程切效率高                                                 |
| 通信     | 进程间通信需跨越进程边界                       | 线程间通信使用共享内存和变量                                 |
| 控制逻辑 | 多进程更为复杂                                 | 多线程控制逻辑更为容易，但是需要线程同步和加锁控制           |
| 数量     | 进程数量由CPU决定                              | 线程数量由进程的空间资源和线程本身栈大小决定                 |



### 1.1.3 什么时候用进程，什么时候用线程

需要频繁快速切换的时候选择线程

需要安全稳定时选择进程







### 1.1.4多进程、多线程同步的方法

进程间通信：

- 管道、无名管道
- 消息队列
- 信号量
- 共享内存
- 信号
- socket

线程间通信：

- 信号量
- 读写锁
- 条件变量
- 互斥锁
- 自旋锁

#### 互斥锁与信号量的区别

互斥锁用于线程互斥，信号量用于线程同步以及进程同步









### 1.1.5 进程的空间模型

![img](https://s2.loli.net/2022/06/23/36YvmCrwjh5SQbi.png)

32位系统，运行程序创建进程时，为其分配4G的虚拟地址空间，3G为用户空间，1G为内核空间

栈：由编译器自动分配和释放，存放函数的参数值，局部变量等

堆：一般由程序员分配和释放，若不释放会造成内存泄漏，程序结束可能又操作系统收回。

全局区：全局变量和静态变量放在一起，分为未初始化（.bss）和初始化（.data）的区域

文字常量区：常量字符串，程序结束后由系统释放（.rodata）

程序代码区：存放函数的二进制代码（.txt）



### 1.1.6 一个进程可以创建多少个线程，和什么有关



一个进程的可用虚拟空间为2G，默认情况下，线程的栈的大小为1MB，理论上可以创建2048个线程。

一个进程可以创建的线程个数由虚拟空间大小以及线程栈的大小决定。







### 1.1.7 进程线程的状态转换图，什么时候阻塞，什么时候就绪？

创建态：进程正在被创建，初识PCB，分配资源

就绪态：进程已具备除CPU外的所有资源

运行态：占用CPU，在处理机上运行

阻塞态：由于等待某些资源而导致进程暂停运行

结束态：撤销进程，撤销PCB，撤销资源

挂起态：由于某些资源得不到，将进程挂入外存

![image-20220530154124719](https://s2.loli.net/2022/06/23/DVRkhzH2lP9ox5I.png)







### 1.1.8 父进程，子进程的关系和区别

子进程继承父进程：

   ○用户号UIDs和用户组号GIDs

   ○环境Environment

   ○堆栈

   ○共享内存

   ○打开文件的描述符

   ○执行时关闭（Close-on-exec）标志

   ○信号（Signal）控制设定

   ○进程组号

   ○当前工作目录

   ○根目录

   ○文件方式创建屏蔽字

   ○资源限制

   ○控制终端

子进程独有的：

   ○进程号PID

   ○不同的父进程号

   ○自己的文件描述符和目录流的拷贝

   ○子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）

   ○不继承异步输入和输出 



父进程：

子进程：由父进程使用fork()系统调用创建。

**联系：**

创建子进程作为父进程的副本；子进程继承父进程大部分的属性。

子进程与父进程拥有相同内容的代码段、数据段和用户堆栈，目录。

**区别**：

子进程拥有自己的进程号PID，拥有独立的地址空间，自己的文件描述符和目录流的拷贝





### 1.1.9 什么是进程上下文，中断上下文

**进程上下文**：

​	一个进程在执行的时候，CPU中的所有寄存器中的值，进程的状态以及堆栈中的内容，当需要切换到另外一个进程时，需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次运行此进程时，能够恢复切换前的状态。

​	切换到内核态后执行的程序，即运行在内核空间的部分。



**中断上下文：**

​	由硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理，中断上下文可以理解为硬件传递过来的这些参数和内核需要保存的一些环境。

​	当用户进程想要访问系统资源，必须通过系统调用或者中断切换到内核态，由内核执行。









## 1.2 并发、同步、异步、互斥、阻塞、非阻塞的理解





### 1.2.1 并发、同步、异步、互斥、阻塞、非阻塞的概念

**并发**：两个或多个事件在同一时间间隔发生，就是微观上交替发生，宏观上同时发生。

**同步**：两个或多个进程的运行必须按照严格的先后顺序进行

**互斥**：对于某些临界资源的访问，需要互斥的进行，同一时段只允许一个进程访问该资源。

**异步**：异步彼此独立，不需要等待某个事件的发生才能工作

**注意：**

1）线程是实现异步的一个方式。可以在主线程创建一个新线程来做某件事，此时主线程不需等待子线程做完而是可以做其他事情。

2）异步和多线程并不是一个同等关系。异步是最终目的,多线程只是我们实现异步的一种手段。

**阻塞**：指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

**非阻塞**：非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。



一般来说可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞。

**同步阻塞**：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果就一直等待，等待期间不做任何操作。

**同步非阻塞**：发送方发出请求后一直等待（同步），接收方开始读取文件，如果不能马上得到读取结果，就立即返回，接收方继续做他事情，此时并未响应发送方，发送发就一直等待，直到接收方读取结果响应发送发，接收方才可以进入下一次请求。

**异步阻塞**：发送方发出请求后，不等待响应，继续其他工作（异步），接收方开始读取文件，如果不能马上得到读取结果就一直等待，等待期间不做任何操作。

**异步非阻塞**：发送方发出请求后，不等待响应，继续其他工作（异步），接收方读取文件如果不能马上得到结果，也不等待，而是马上返回取做其他事情。当IO操作（读取文件）完成以后，将完成状态和结果通知接收方，接收方在响应发送方。（效率最高）

**总结：** 

1）同步与异步是对应的，它们是线程之间的关系，两个线程之间要么是同步的，要么是异步的。

2）阻塞与非阻塞是对同一个线程来说的，在某个时刻，线程要么处于阻塞，要么处于非阻塞。

3）阻塞是使用同步机制的结果，非阻塞则是使用异步机制的结果。



### 1.2.2 什么是线程同步和互斥

线程同步：线程之间的一种制约关系，一个线程依赖另一个线程的消息，每个线程都按照约定的先后次序运行

线程互斥：针对共享的临界资源，同一时段只允许一个线程访问资源，直到占用资源者释放资源后，其他线程才可以访问。





### 1.2.3 线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步吗？

**同步是一个过程，阻塞是一种状态。**

**线程同步不一定发生阻塞**，线程同步时，只有两个资源出现相互等待和相互唤醒时才会出现阻塞。











## 1.3 孤儿进程、僵尸进程、守护进程的概念







### 1.3.1 基本概念

**孤儿进程**：当父进程退出时，子进程仍然在运行，则子进程就是孤儿进程。

**僵尸进程**：子进程退出后，父进程没有调用wait()函数接收结束子进程，子进程停留在系统中，这就是僵尸进程。

**守护进程**：守护进程不受终端影响，退出终端也可以运行。



### 1.3.2 如何创建守护进程

1）**创建子进程，退出父进程**。利用`fork()`函数。

2）**创建新会话，摆脱终端影响**。利用`setsid()`函数创建新会话，并担任该会话组的组长，摆脱原会话的控制==>摆脱原进程的控制==>摆脱原控制台的控制。

3）**改变守护进程的工作目录为根目录**。利用`chrdir()`函数改变目录。

4）**重设文件权限掩码**。子进程继承了父进程的权限掩码，通过`umask()`函数屏蔽掉文件权限中的对应位，需要将子进程置零，拥有较大权限，提高守护进程灵活度。

5）**关闭不需要的文件描述符**。从父进程继承的文件描述符，不需要的可以关闭。

```c
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <string.h>
#include <fcntl.h>

int main()
{
        pid_t pid;
        int fd,len,i,num;
        char *buf="the dameon is running\n";
        len =strlen(buf)+1;


        pid=fork();
        if(pid>0)
        {
                exit(0);
        }

        //创建新会话，摆脱终端影响
        setsid();

        //改变当前工作目录
        chdir("/");

        //重设文件权限掩码
        umask(0);

        for(int i=0;i<3;i++)
        {
                close(i);
        }

        while(1)
        {
                fd=open("/var/log/dameon.log",O_CREAT|O_WRONLY|O_APPEND,0666);
                write(fd,buf,len);
                close(fd);
                sleep(5);
        }
        return 0;
}
```









### 1.3.2 正确处理孤儿进程、僵尸进程的方法

**孤儿进程的处理：**

​	孤儿进程会有linux系统中的1号进程init进程来处理，他利用wait()函数来处理已经退出的子程序

**僵尸进程的处理：**

​	如果父进程一直不调用wait/waitpid函数接收子进程，那么子进程就一直保存在系统里，占用系统资源，因此如果僵尸进程数量太多，那么就会导致系统空间爆满，无法创建新的进程，严重系统工作

​	系统规定，子进程退出后，父进程会自动收到SIGCHLD信号。因此我们需要在父进程里重置signal函数。每当子进程退出，父进程都会收到SIGCHLD信号，故通过signal函数，重置信号响应函数。

```c
void* handler(int sig)
{
    int status;
    if(waitpid(-1, &status, WNOHANG) >= 0)
    {
        printf("child is die\n");
    }
}
int main()
{
    signal(SIGCHLD, handler);
    int pid = fork();
    if(pid > 0)  //父进程循环等待
    {
        while(1)
        {
            sleep(2);
        }
    
    }else if(0 == pid){   //子进程说自己die后就结束生命周期，之后父进程就收到SIGCHLD
                          //信号调用handler函数接收结束子进程，打印child is die。
        printf("i am child, i die\n");
    }
}
```





```c
pid_t wait(int *status);
pid_t waitpid(pid_t pid,int *status,int options);
```

`wait()`:

​	成功返回`pid`，失败返回-1；

`status:`

WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）

WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）



`waitpid()`:

​	成功返回`pid`，失败返回-1；

`pid：`

​	pid=-1,等待任意一个子进程，和wait等效

​	pid>0:只等待进程id等于pid的进程

​	pid=0:等待同一进程组的任意一个进程，如果子进程加入其他进程组不加理会

​	pid<-1时，等待一个指定进程组中的任意一个进程，这个进程组的id就是pid的绝对值

`status:`

​	WIFEXITED 若为正常终止子进程返回的状态，则为真，（查看进程是否正常退出）

​	WEXITSTATUS:若WIFEXITED 非零，提取子进程退出码（查看进程退出码）

`options:`

​	WNOHANG:若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回孩子进程的进程id



waitpid有wait没有的三个功能：

（1）waitpid能等待一个特定的子进程，而wait只能等待任意的子进程，

（2）系统一旦调用wait函数就会阻塞父进程来等待，直到等到子进程的退出才停止阻塞，而waitpid提供了一种非阻塞方式的等待，也就是第三个参数，当第三个参数设置为WNOHANG，当子进程没有结束，直接返回0，不等待

（3）waitpid支持作业控制，提供用于检查wait和waitpid返回状态的宏这两个函数返回的子进程的状态都保存在status指针中

WIFEXITED(status): 若为正常终止, 则为真. 此时可执行 WEXITSTATUS(status): 取子进程传送给exit或_exit参数的低8位.

WIFSIGNALED(status): 若为异常终止, 则为真.此时可执行 WTERMSIG(status): 取使子进程终止的信号编号.

WIFSTOPPED(status): 若为当前暂停子进程, 则为真. 此时可执行 WSTOPSIG(status): 取使子进程暂停的信号编号
